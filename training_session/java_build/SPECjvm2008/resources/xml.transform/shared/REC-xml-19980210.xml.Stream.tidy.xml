<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org" />
<meta http-equiv="Content-Type"
content="text/html; charset=UTF-8" />
<title>Extensible Markup Language (XML) 1.0</title>
<link rel="stylesheet" type="text/css"
href="http://www.w3.org/StyleSheets/TR/W3C-REC" />
<style type="text/css">
code { font-family: monospace }
</style>
</head>
<body>
<div class="head"><a href="http://www.w3.org/"><img
src="http://www.w3.org/Icons/WWW/w3c_home" alt="W3C" /></a>
<h1>Extensible Markup Language (XML) 1.0<br />
</h1>

<h2>W3C Recommendation</h2>

<dl>
<dt>This version:</dt>

<dd><a
href="http://www.w3.org/TR/1998/REC-xml-">http://www.w3.org/TR/1998/REC-xml-</a><br />

<a
href="http://www.w3.org/TR/1998/REC-xml-.xml">http://www.w3.org/TR/1998/REC-xml-.xml</a><br />

<a
href="http://www.w3.org/TR/1998/REC-xml-.html">http://www.w3.org/TR/1998/REC-xml-.html</a><br />

<a
href="http://www.w3.org/TR/1998/REC-xml-.pdf">http://www.w3.org/TR/1998/REC-xml-.pdf</a><br />

<a
href="http://www.w3.org/TR/1998/REC-xml-.ps">http://www.w3.org/TR/1998/REC-xml-.ps</a><br />

</dd>

<dt>Latest version:</dt>

<dd><a
href="http://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml</a><br />

</dd>

<dt>Previous version:</dt>

<dd><a
href="http://www.w3.org/TR/PR-xml-971208">http://www.w3.org/TR/PR-xml-971208</a><br />

</dd>

<dt>Editors:</dt>

<dd>Tim Bray (Textuality and Netscape) <a
href="mailto:tbray@textuality.com">&lt;tbray@textuality.com&gt;</a><br />

Jean Paoli (Microsoft) <a
href="mailto:jeanpa@microsoft.com">&lt;jeanpa@microsoft.com&gt;</a><br />

C. M. Sperberg-McQueen (University of Illinois at Chicago) <a
href="mailto:cmsmcq@uic.edu">&lt;cmsmcq@uic.edu&gt;</a><br />
</dd>
</dl>

<p class="copyright"><a
href="http://www.w3.org/Consortium/Legal/ipr-notice.html#Copyright">
Copyright</a>  ©  1999 <a href="http://www.w3.org">W3C</a> (<a
href="http://www.lcs.mit.edu">MIT</a>, <a
href="http://www.inria.fr/">INRIA</a>, <a
href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C
<a
href="http://www.w3.org/Consortium/Legal/ipr-notice.html#Legal_Disclaimer">
liability</a>, <a
href="http://www.w3.org/Consortium/Legal/ipr-notice.html#W3C_Trademarks">
trademark</a>, <a
href="http://www.w3.org/Consortium/Legal/copyright-documents.html">document
use</a> and <a
href="http://www.w3.org/Consortium/Legal/copyright-software.html">software
licensing</a> rules apply.</p>

<hr title="Separator for header" />
</div>

<h2><a id="abstract" name="abstract">Abstract</a></h2>

<p>The Extensible Markup Language (XML) is a subset of SGML that is
completely described in this document. Its goal is to enable
generic SGML to be served, received, and processed on the Web in
the way that is now possible with HTML. XML has been designed for
ease of implementation and for interoperability with both SGML and
HTML.</p>

<h2><a id="status" name="status">Status of this document</a></h2>

<p>This document has been reviewed by W3C Members and other
interested parties and has been endorsed by the Director as a W3C
Recommendation. It is a stable document and may be used as
reference material or cited as a normative reference from another
document. W3C's role in making the Recommendation is to draw
attention to the specification and to promote its widespread
deployment. This enhances the functionality and interoperability of
the Web.</p>

<p>This document specifies a syntax created by subsetting an
existing, widely used international text processing standard
(Standard Generalized Markup Language, ISO 8879:1986(E) as amended
and corrected) for use on the World Wide Web. It is a product of
the W3C XML Activity, details of which can be found at <a
href="http://www.w3.org/XML">http://www.w3.org/XML</a>. A list of
current W3C Recommendations and other technical documents can be
found at <a
href="http://www.w3.org/TR">http://www.w3.org/TR</a>.</p>

<p>This specification uses the term URI, which is defined by <a
href="#Berners-Lee">[]</a>, a work in progress expected to update
<a href="#RFC1738">[]</a> and <a href="#RFC1808">[]</a>.</p>

<p>The list of known errors in this specification is available at
<a
href="http://www.w3.org/XML/xml-19980210-errata">http://www.w3.org/XML/xml-19980210-errata</a>.</p>

<p>Please report errors in this document to <a
href="mailto:xml-editor@w3.org">xml-editor@w3.org</a>.</p>

<h2><a id="contents" name="contents">Table of contents</a></h2>

1 <a href="#sec-intro">Introduction</a><br />
    1.1 <a href="#sec-origin-goals">Origin and Goals</a><br />
    1.2 <a href="#sec-terminology">Terminology</a><br />
2 <a href="#sec-documents">Documents</a><br />
    2.1 <a href="#sec-well-formed">Well-Formed XML
Documents</a><br />
    2.2 <a href="#charsets">Characters</a><br />
    2.3 <a href="#sec-common-syn">Common Syntactic
Constructs</a><br />
    2.4 <a href="#syntax">Character Data and Markup</a><br />
    2.5 <a href="#sec-comments">Comments</a><br />
    2.6 <a href="#sec-pi">Processing Instructions</a><br />
    2.7 <a href="#sec-cdata-sect">CDATA Sections</a><br />
    2.8 <a href="#sec-prolog-dtd">Prolog and Document Type
Declaration</a><br />
    2.9 <a href="#sec-rmd">Standalone Document
Declaration</a><br />
    2.10 <a href="#sec-white-space">White Space Handling</a><br />
    2.11 <a href="#sec-line-ends">End-of-Line Handling</a><br />
    2.12 <a href="#sec-lang-tag">Language Identification</a><br />
3 <a href="#sec-logical-struct">Logical Structures</a><br />
    3.1 <a href="#sec-starttags">Start-Tags, End-Tags, and
Empty-Element Tags</a><br />
    3.2 <a href="#elemdecls">Element Type Declarations</a><br />
        3.2.1 <a href="#sec-element-content">Element
Content</a><br />
        3.2.2 <a href="#sec-mixed-content">Mixed Content</a><br />
    3.3 <a href="#attdecls">Attribute-List Declarations</a><br />
        3.3.1 <a href="#sec-attribute-types">Attribute
Types</a><br />
        3.3.2 <a href="#sec-attr-defaults">Attribute
Defaults</a><br />
        3.3.3 <a href="#AVNormalize">Attribute-Value
Normalization</a><br />
    3.4 <a href="#sec-condition-sect">Conditional
Sections</a><br />
4 <a href="#sec-physical-struct">Physical Structures</a><br />
    4.1 <a href="#sec-references">Character and Entity
References</a><br />
    4.2 <a href="#sec-entity-decl">Entity Declarations</a><br />
        4.2.1 <a href="#sec-internal-ent">Internal
Entities</a><br />
        4.2.2 <a href="#sec-external-ent">External
Entities</a><br />
    4.3 <a href="#TextEntities">Parsed Entities</a><br />
        4.3.1 <a href="#sec-TextDecl">The Text
Declaration</a><br />
        4.3.2 <a href="#wf-entities">Well-Formed Parsed
Entities</a><br />
        4.3.3 <a href="#charencoding">Character Encoding in
Entities</a><br />
    4.4 <a href="#entproc">XML Processor Treatment of Entities and
References</a><br />
        4.4.1 <a href="#not-recognized">Not Recognized</a><br />
        4.4.2 <a href="#included">Included</a><br />
        4.4.3 <a href="#include-if-valid">Included If
Validating</a><br />
        4.4.4 <a href="#forbidden">Forbidden</a><br />
        4.4.5 <a href="#inliteral">Included in Literal</a><br />
        4.4.6 <a href="#notify">Notify</a><br />
        4.4.7 <a href="#bypass">Bypassed</a><br />
        4.4.8 <a href="#as-PE">Included as PE</a><br />
    4.5 <a href="#intern-replacement">Construction of Internal
Entity Replacement Text</a><br />
    4.6 <a href="#sec-predefined-ent">Predefined Entities</a><br />
    4.7 <a href="#Notations">Notation Declarations</a><br />
    4.8 <a href="#sec-doc-entity">Document Entity</a><br />
5 <a href="#sec-conformance">Conformance</a><br />
    5.1 <a href="#proc-types">Validating and Non-Validating
Processors</a><br />
    5.2 <a href="#safe-behavior">Using XML Processors</a><br />
6 <a href="#sec-notation">Notation</a><br />
<h3>Appendices</h3>

A <a href="#sec-bibliography">References</a><br />
    A.1 <a href="#sec-existing-stds">Normative References</a><br />
    A.2 <a href="#section-Other-References">Other
References</a><br />
B <a href="#CharClasses">Character Classes</a><br />
C <a href="#sec-xml-and-sgml">XML and SGML</a>
(Non-Normative)<br />
D <a href="#sec-entexpand">Expansion of Entity and Character
References</a> (Non-Normative)<br />
E <a href="#determinism">Deterministic Content Models</a>
(Non-Normative)<br />
F <a href="#sec-guessing">Autodetection of Character Encodings</a>
(Non-Normative)<br />
G <a href="#sec-xml-wg">W3C XML Working Group</a>
(Non-Normative)<br />
<hr />
<h2><a id="sec-intro" name="sec-intro"></a>1 Introduction</h2>

<p>Extensible Markup Language, abbreviated XML, describes a class
of data objects called <a href="#dt-xml-doc">XML documents</a> and
partially describes the behavior of computer programs which process
them. XML is an application profile or restricted form of SGML, the
Standard Generalized Markup Language <a href="#ISO8879">[]</a>. By
construction, XML documents are conforming SGML documents.</p>

<p>XML documents are made up of storage units called <a
href="#dt-entity">entities</a>, which contain either parsed or
unparsed data. Parsed data is made up of <a
href="#dt-character">characters</a>, some of which form <a
href="#dt-chardata">character data</a>, and some of which form <a
href="#dt-markup">markup</a>. Markup encodes a description of the
document's storage layout and logical structure. XML provides a
mechanism to impose constraints on the storage layout and logical
structure.</p>

<p><a id="dt-xml-proc" name="dt-xml-proc"></a>A software module
called an <b>XML processor</b> is used to read XML documents and
provide access to their content and structure. <a id="dt-app"
name="dt-app"></a>It is assumed that an XML processor is doing its
work on behalf of another module, called the <b>application</b>.
This specification describes the required behavior of an XML
processor in terms of how it must read XML data and the information
it must provide to the application.</p>

<h3><a id="sec-origin-goals" name="sec-origin-goals"></a>1.1 Origin
and Goals</h3>

<p>XML was developed by an XML Working Group (originally known as
the SGML Editorial Review Board) formed under the auspices of the
World Wide Web Consortium (W3C) in 1996. It was chaired by Jon
Bosak of Sun Microsystems with the active participation of an XML
Special Interest Group (previously known as the SGML Working Group)
also organized by the W3C. The membership of the XML Working Group
is given in an appendix. Dan Connolly served as the WG's contact
with the W3C.</p>

<p>The design goals for XML are:</p>

<ol>
<li>
<p>XML shall be straightforwardly usable over the Internet.</p>
</li>

<li>
<p>XML shall support a wide variety of applications.</p>
</li>

<li>
<p>XML shall be compatible with SGML.</p>
</li>

<li>
<p>It shall be easy to write programs which process XML
documents.</p>
</li>

<li>
<p>The number of optional features in XML is to be kept to the
absolute minimum, ideally zero.</p>
</li>

<li>
<p>XML documents should be human-legible and reasonably clear.</p>
</li>

<li>
<p>The XML design should be prepared quickly.</p>
</li>

<li>
<p>The design of XML shall be formal and concise.</p>
</li>

<li>
<p>XML documents shall be easy to create.</p>
</li>

<li>
<p>Terseness in XML markup is of minimal importance.</p>
</li>
</ol>

<br />
<br />
 

<p>This specification, together with associated standards (Unicode
and ISO/IEC 10646 for characters, Internet RFC 1766 for language
identification tags, ISO 639 for language name codes, and ISO 3166
for country name codes), provides all the information necessary to
understand XML Version and construct computer programs to process
it.</p>

<p>This version of the XML specification .</p>

<h3><a id="sec-terminology" name="sec-terminology"></a>1.2
Terminology</h3>

<p>The terminology used to describe XML documents is defined in the
body of this specification. The terms defined in the following list
are used in building those definitions and in describing the
actions of an XML processor:</p>

<dl>
<dt><b>may</b></dt>

<dd>
<p><a id="dt-may" name="dt-may"></a>Conforming documents and XML
processors are permitted to but need not behave as described.</p>
</dd>

<dt><b>must</b></dt>

<dd>
<p>Conforming documents and XML processors are required to behave
as described; otherwise they are in error.</p>
</dd>

<dt><b>error</b></dt>

<dd>
<p><a id="dt-error" name="dt-error"></a>A violation of the rules of
this specification; results are undefined. Conforming software may
detect and report an error and may recover from it.</p>
</dd>

<dt><b>fatal error</b></dt>

<dd>
<p><a id="dt-fatal" name="dt-fatal"></a>An error which a conforming
<a href="#dt-xml-proc">XML processor</a> must detect and report to
the application. After encountering a fatal error, the processor
may continue processing the data to search for further errors and
may report such errors to the application. In order to support
correction of errors, the processor may make unprocessed data from
the document (with intermingled character data and markup)
available to the application. Once a fatal error is detected,
however, the processor must not continue normal processing (i.e.,
it must not continue to pass character data and information about
the document's logical structure to the application in the normal
way).</p>
</dd>

<dt><b>at user option</b></dt>

<dd>
<p>Conforming software may or must (depending on the modal verb in
the sentence) behave as described; if it does, it must provide
users a means to enable or disable the behavior described.</p>
</dd>

<dt><b>validity constraint</b></dt>

<dd>
<p>A rule which applies to all <a href="#dt-valid">valid</a> XML
documents. Violations of validity constraints are errors; they
must, at user option, be reported by <a
href="#dt-validating">validating XML processors</a>.</p>
</dd>

<dt><b>well-formedness constraint</b></dt>

<dd>
<p>A rule which applies to all <a
href="#dt-wellformed">well-formed</a> XML documents. Violations of
well-formedness constraints are <a href="#dt-fatal">fatal
errors</a>.</p>
</dd>

<dt><b>match</b></dt>

<dd>
<p><a id="dt-match" name="dt-match"></a>(Of strings or names:) Two
strings or names being compared must be identical. Characters with
multiple possible representations in ISO/IEC 10646 (e.g. characters
with both precomposed and base+diacritic forms) match only if they
have the same representation in both strings. At user option,
processors may normalize such characters to some canonical form. No
case folding is performed. (Of strings and rules in the grammar:) A
string matches a grammatical production if it belongs to the
language generated by that production. (Of content and content
models:) An element matches its declaration when it conforms in the
fashion described in the constraint <a
href="#elementvalid">[]</a>.</p>
</dd>

<dt><b>for compatibility</b></dt>

<dd>
<p><a id="dt-compat" name="dt-compat"></a>A feature of XML included
solely to ensure that XML remains compatible with SGML.</p>
</dd>

<dt><b>for interoperability</b></dt>

<dd>
<p><a id="dt-interop" name="dt-interop"></a>A non-binding
recommendation included to increase the chances that XML documents
can be processed by the existing installed base of SGML processors
which predate the .</p>
</dd>
</dl>

<br />
<br />
 

<h2><a id="sec-documents" name="sec-documents"></a>2 Documents</h2>

<p><a id="dt-xml-doc" name="dt-xml-doc"></a> A data object is an
<b>XML document</b> if it is <a
href="#dt-wellformed">well-formed</a>, as defined in this
specification. A well-formed XML document may in addition be <a
href="#dt-valid">valid</a> if it meets certain further
constraints.</p>

<p>Each XML document has both a logical and a physical structure.
Physically, the document is composed of units called <a
href="#dt-entity">entities</a>. An entity may <a
href="#dt-entref">refer</a> to other entities to cause their
inclusion in the document. A document begins in a "root" or <a
href="#dt-docent">document entity</a>. Logically, the document is
composed of declarations, elements, comments, character references,
and processing instructions, all of which are indicated in the
document by explicit markup. The logical and physical structures
must nest properly, as described in <a
href="#wf-entities">[]</a>.</p>

<h3><a id="sec-well-formed" name="sec-well-formed"></a>2.1
Well-Formed XML Documents</h3>

<p><a id="dt-wellformed" name="dt-wellformed"></a> A textual object
is a well-formed XML document if:</p>

<ol>
<li>
<p>Taken as a whole, it matches the production labeled <a
href="#NT-document">document</a>.</p>
</li>

<li>
<p>It meets all the well-formedness constraints given in this
specification.</p>
</li>

<li>
<p>Each of the <a href="#dt-parsedent">parsed entities</a> which is
referenced directly or indirectly within the document is <a
href="#wf-entities">well-formed</a>.</p>
</li>
</ol>

<br />
<br />
 

<h5>Document</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-document" name="NT-document"></a>[1]   </td>
<td>document</td>
<td>   ::=   </td>
<td><a href="#NT-prolog">prolog</a> <a
href="#NT-element">element</a> <a href="#NT-Misc">Misc</a>*</td>
<td></td>
</tr>
</tbody>
</table>

<br />
<br />
 

<p>Matching the <a href="#NT-document">document</a> production
implies that:</p>

<ol>
<li>
<p>It contains one or more <a href="#dt-element">elements</a>.</p>
</li>

<li>
<p><a id="dt-root" name="dt-root"></a>There is exactly one element,
called the <b>root</b>, or document element, no part of which
appears in the <a href="#dt-content">content</a> of any other
element. For all other elements, if the start-tag is in the content
of another element, the end-tag is in the content of the same
element. More simply stated, the elements, delimited by start- and
end-tags, nest properly within each other.</p>
</li>
</ol>

<br />
<br />
 

<p><a id="dt-parentchild" name="dt-parentchild"></a>As a
consequence of this, for each non-root element <code>C</code> in
the document, there is one other element <code>P</code> in the
document such that <code>C</code> is in the content of
<code>P</code>, but is not in the content of any other element that
is in the content of <code>P</code>. <code>P</code> is referred to
as the <b>parent</b> of <code>C</code>, and <code>C</code> as a
<b>child</b> of <code>P</code>.</p>

<h3><a id="charsets" name="charsets"></a>2.2 Characters</h3>

<p><a id="dt-text" name="dt-text"></a>A parsed entity contains
<b>text</b>, a sequence of <a href="#dt-character">characters</a>,
which may represent markup or character data. <a id="dt-character"
name="dt-character"></a>A <b>character</b> is an atomic unit of
text as specified by ISO/IEC 10646 <a href="#ISO10646">[]</a>.
Legal characters are tab, carriage return, line feed, and the legal
graphic characters of Unicode and ISO/IEC 10646. The use of
"compatibility characters", as defined in section 6.8 of <a
href="#Unicode">[]</a>, is discouraged.</p>

<h5>Character Range</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-Char" name="NT-Char"></a>[2]   </td>
<td>Char</td>
<td>   ::=   </td>
<td>#x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] |
[#x10000-#x10FFFF]</td>
<td>/*any Unicode character, excluding the surrogate blocks, FFFE,
and FFFF.*/</td>
</tr>
</tbody>
</table>

<br />
<br />
 

<p>The mechanism for encoding character code points into bit
patterns may vary from entity to entity. All XML processors must
accept the UTF-8 and UTF-16 encodings of 10646; the mechanisms for
signaling which of the two is in use, or for bringing other
encodings into play, are discussed later, in <a
href="#charencoding">[]</a>.</p>

<h3><a id="sec-common-syn" name="sec-common-syn"></a>2.3 Common
Syntactic Constructs</h3>

<p>This section defines some symbols used widely in the
grammar.</p>

<p><a href="#NT-S">S</a> (white space) consists of one or more
space (#x20) characters, carriage returns, line feeds, or tabs.</p>

<h5>White Space</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-S" name="NT-S"></a>[3]   </td>
<td>S</td>
<td>   ::=   </td>
<td>(#x20 | #x9 | #xD | #xA)+</td>
<td></td>
</tr>
</tbody>
</table>

<br />
<br />
 

<p>Characters are classified for convenience as letters, digits, or
other characters. Letters consist of an alphabetic or syllabic base
character possibly followed by one or more combining characters, or
of an ideographic character. Full definitions of the specific
characters in each class are given in <a
href="#CharClasses">[]</a>.</p>

<p><a id="dt-name" name="dt-name"></a>A <b>Name</b> is a token
beginning with a letter or one of a few punctuation characters, and
continuing with letters, digits, hyphens, underscores, colons, or
full stops, together known as name characters. Names beginning with
the string "<code>xml</code>", or any string which would match
<code>(('X'|'x') ('M'|'m') ('L'|'l'))</code>, are reserved for
standardization in this or future versions of this
specification.</p>

<blockquote><b>NOTE:</b> The colon character within XML names is
reserved for experimentation with name spaces. Its meaning is
expected to be standardized at some future point, at which point
those documents using the colon for experimental purposes may need
to be updated. (There is no guarantee that any name-space mechanism
adopted for XML will in fact use the colon as a name-space
delimiter.) In practice, this means that authors should not use the
colon in XML names except as part of name-space experiments, but
that XML processors should accept the colon as a name
character.</blockquote>

<p>An <a href="#NT-Nmtoken">Nmtoken</a> (name token) is any mixture
of name characters.</p>

<h5>Names and Tokens</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-NameChar" name="NT-NameChar"></a>[4]   </td>
<td>NameChar</td>
<td>   ::=   </td>
<td><a href="#NT-Letter">Letter</a> | <a href="#NT-Digit">Digit</a>
| '.' | '-' | '_' | ':' | <a
href="#NT-CombiningChar">CombiningChar</a> | <a
href="#NT-Extender">Extender</a></td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-Name" name="NT-Name"></a>[5]   </td>
<td>Name</td>
<td>   ::=   </td>
<td>(<a href="#NT-Letter">Letter</a> | '_' | ':') (<a
href="#NT-NameChar">NameChar</a>)*</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-Names" name="NT-Names"></a>[6]   </td>
<td>Names</td>
<td>   ::=   </td>
<td><a href="#NT-Name">Name</a> (<a href="#NT-S">S</a> <a
href="#NT-Name">Name</a>)*</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-Nmtoken" name="NT-Nmtoken"></a>[7]   </td>
<td>Nmtoken</td>
<td>   ::=   </td>
<td>(<a href="#NT-NameChar">NameChar</a>)+</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-Nmtokens" name="NT-Nmtokens"></a>[8]   </td>
<td>Nmtokens</td>
<td>   ::=   </td>
<td><a href="#NT-Nmtoken">Nmtoken</a> (<a href="#NT-S">S</a> <a
href="#NT-Nmtoken">Nmtoken</a>)*</td>
<td></td>
</tr>
</tbody>
</table>

<br />
<br />
 

<p>Literal data is any quoted string not containing the quotation
mark used as a delimiter for that string. Literals are used for
specifying the content of internal entities (<a
href="#NT-EntityValue">EntityValue</a>), the values of attributes
(<a href="#NT-AttValue">AttValue</a>), and external identifiers (<a
href="#NT-SystemLiteral">SystemLiteral</a>). Note that a <a
href="#NT-SystemLiteral">SystemLiteral</a> can be parsed without
scanning for markup.</p>

<h5>Literals</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-EntityValue" name="NT-EntityValue"></a>[9]   </td>
<td>EntityValue</td>
<td>   ::=   </td>
<td>'"' ([^%&amp;"] | <a href="#NT-PEReference">PEReference</a> |
<a href="#NT-Reference">Reference</a>)* '"'</td>
<td></td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td>| "'" ([^%&amp;'] | <a href="#NT-PEReference">PEReference</a> |
<a href="#NT-Reference">Reference</a>)* "'"</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-AttValue" name="NT-AttValue"></a>[10]   </td>
<td>AttValue</td>
<td>   ::=   </td>
<td>'"' ([^&lt;&amp;"] | <a href="#NT-Reference">Reference</a>)*
'"'</td>
<td></td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td>| "'" ([^&lt;&amp;'] | <a href="#NT-Reference">Reference</a>)*
"'"</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-SystemLiteral"
name="NT-SystemLiteral"></a>[11]   </td>
<td>SystemLiteral</td>
<td>   ::=   </td>
<td>('"' [^"]* '"') |("'" [^']* "'")</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-PubidLiteral" name="NT-PubidLiteral"></a>[12]   </td>
<td>PubidLiteral</td>
<td>   ::=   </td>
<td>'"' <a href="#NT-PubidChar">PubidChar</a>* '"' | "'" (<a
href="#NT-PubidChar">PubidChar</a> - "'")* "'"</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-PubidChar" name="NT-PubidChar"></a>[13]   </td>
<td>PubidChar</td>
<td>   ::=   </td>
<td>#x20 | #xD | #xA |[a-zA-Z0-9] |[-'()+,./:=?;!*#@$_%]</td>
<td></td>
</tr>
</tbody>
</table>

<br />
<br />
 

<h3><a id="syntax" name="syntax"></a>2.4 Character Data and
Markup</h3>

<p><a href="#dt-text">Text</a> consists of intermingled <a
href="#dt-chardata">character data</a> and markup. <a
id="dt-markup" name="dt-markup"></a><b>Markup</b> takes the form of
<a href="#dt-stag">start-tags</a>, <a href="#dt-etag">end-tags</a>,
<a href="#dt-empty">empty-element tags</a>, <a
href="#dt-entref">entity references</a>, <a
href="#dt-charref">character references</a>, <a
href="#dt-comment">comments</a>, <a href="#dt-cdsection">CDATA
section</a> delimiters, <a href="#dt-doctype">document type
declarations</a>, and <a href="#dt-pi">processing
instructions</a>.</p>

<p><a id="dt-chardata" name="dt-chardata"></a>All text that is not
markup constitutes the <b>character data</b> of the document.</p>

<p>The ampersand character (&amp;) and the left angle bracket
(&lt;) may appear in their literal form <i>only</i> when used as
markup delimiters, or within a <a href="#dt-comment">comment</a>, a
<a href="#dt-pi">processing instruction</a>, or a <a
href="#dt-cdsection">CDATA section</a>. They are also legal within
the <a href="#dt-litentval">literal entity value</a> of an internal
entity declaration; see <a href="#wf-entities">[]</a>. If they are
needed elsewhere, they must be <a href="#dt-escape">escaped</a>
using either <a href="#dt-charref">numeric character references</a>
or the strings "<code>&amp;amp;</code>" and "<code>&amp;lt;</code>"
respectively. The right angle bracket (&gt;) may be represented
using the string "<code>&amp;gt;</code>", and must, <a
href="#dt-compat">for compatibility</a>, be escaped using
"<code>&amp;gt;</code>" or a character reference when it appears in
the string "<code>]]&gt;</code>" in content, when that string is
not marking the end of a <a href="#dt-cdsection">CDATA
section</a>.</p>

<p>In the content of elements, character data is any string of
characters which does not contain the start-delimiter of any
markup. In a CDATA section, character data is any string of
characters not including the CDATA-section-close delimiter,
"<code>]]&gt;</code>".</p>

<p>To allow attribute values to contain both single and double
quotes, the apostrophe or single-quote character (') may be
represented as "<code>&amp;apos;</code>", and the double-quote
character (") as "<code>&amp;quot;</code>".</p>

<h5>Character Data</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-CharData" name="NT-CharData"></a>[14]   </td>
<td>CharData</td>
<td>   ::=   </td>
<td>[^&lt;&amp;]* - ([^&lt;&amp;]* ']]&gt;' [^&lt;&amp;]*)</td>
<td></td>
</tr>
</tbody>
</table>

<br />
<br />
 

<h3><a id="sec-comments" name="sec-comments"></a>2.5 Comments</h3>

<p><a id="dt-comment" name="dt-comment"></a><b>Comments</b> may
appear anywhere in a document outside other <a
href="#dt-markup">markup</a>; in addition, they may appear within
the document type declaration at places allowed by the grammar.
They are not part of the document's <a
href="#dt-chardata">character data</a>; an XML processor may, but
need not, make it possible for an application to retrieve the text
of comments. <a href="#dt-compat">For compatibility</a>, the string
"<code>--</code>" (double-hyphen) must not occur within
comments.</p>

<h5>Comments</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-Comment" name="NT-Comment"></a>[15]   </td>
<td>Comment</td>
<td>   ::=   </td>
<td>'&lt;!--' ((<a href="#NT-Char">Char</a> - '-') | ('-' (<a
href="#NT-Char">Char</a> - '-')))* '--&gt;'</td>
<td></td>
</tr>
</tbody>
</table>

<br />
<br />
 

<p>An example of a comment:</p>

<pre>
&lt;!declarations for &lt;head&gt; &amp; &lt;body&gt; &gt;
</pre>

<br />
<br />
 

<h3><a id="sec-pi" name="sec-pi"></a>2.6 Processing
Instructions</h3>

<p><a id="dt-pi" name="dt-pi"></a><b>Processing instructions</b>
(PIs) allow documents to contain instructions for applications.</p>

<h5>Processing Instructions</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-PI" name="NT-PI"></a>[16]   </td>
<td>PI</td>
<td>   ::=   </td>
<td>'&lt;?' <a href="#NT-PITarget">PITarget</a> (<a
href="#NT-S">S</a> (<a href="#NT-Char">Char</a>* - (<a
href="#NT-Char">Char</a>* <a href="#NT-Char">Char</a>*)))?</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-PITarget" name="NT-PITarget"></a>[17]   </td>
<td>PITarget</td>
<td>   ::=   </td>
<td><a href="#NT-Name">Name</a> - (('X' | 'x') ('M' | 'm') ('L' |
'l'))</td>
<td></td>
</tr>
</tbody>
</table>

PIs are not part of the document's <a href="#dt-chardata">character
data</a>, but must be passed through to the application. The PI
begins with a target (<a href="#NT-PITarget">PITarget</a>) used to
identify the application to which the instruction is directed. The
target names "<code>XML</code>", "<code>xml</code>", and so on are
reserved for standardization in this or future versions of this
specification. The XML <a href="#dt-notation">Notation</a>
mechanism may be used for formal declaration of PI targets. <br />
<br />
 

<h3><a id="sec-cdata-sect" name="sec-cdata-sect"></a>2.7 CDATA
Sections</h3>

<p><a id="dt-cdsection" name="dt-cdsection"></a><b>CDATA
sections</b> may occur anywhere character data may occur; they are
used to escape blocks of text containing characters which would
otherwise be recognized as markup. CDATA sections begin with the
string "<code>&lt;![CDATA[</code>" and end with the string
"<code>]]&gt;</code>":</p>

<h5>CDATA Sections</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-CDSect" name="NT-CDSect"></a>[18]   </td>
<td>CDSect</td>
<td>   ::=   </td>
<td><a href="#NT-CDStart">CDStart</a> <a href="#NT-CData">CData</a>
<a href="#NT-CDEnd">CDEnd</a></td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-CDStart" name="NT-CDStart"></a>[19]   </td>
<td>CDStart</td>
<td>   ::=   </td>
<td>'&lt;![CDATA['</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-CData" name="NT-CData"></a>[20]   </td>
<td>CData</td>
<td>   ::=   </td>
<td>(<a href="#NT-Char">Char</a>* - (<a href="#NT-Char">Char</a>*
']]&gt;' <a href="#NT-Char">Char</a>*))</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-CDEnd" name="NT-CDEnd"></a>[21]   </td>
<td>CDEnd</td>
<td>   ::=   </td>
<td>']]&gt;'</td>
<td></td>
</tr>
</tbody>
</table>

Within a CDATA section, only the <a href="#NT-CDEnd">CDEnd</a>
string is recognized as markup, so that left angle brackets and
ampersands may occur in their literal form; they need not (and
cannot) be escaped using "<code>&amp;lt;</code>" and
"<code>&amp;amp;</code>". CDATA sections cannot nest. <br />
<br />
 

<p>An example of a CDATA section, in which
"<code>&lt;greeting&gt;</code>" and
"<code>&lt;/greeting&gt;</code>" are recognized as <a
href="#dt-chardata">character data</a>, not <a
href="#dt-markup">markup</a>:</p>

<pre>
&lt;![CDATA[&lt;greeting&gt;Hello, world!&lt;/greeting&gt;]]&gt;
</pre>

<br />
<br />
 

<h3><a id="sec-prolog-dtd" name="sec-prolog-dtd"></a>2.8 Prolog and
Document Type Declaration</h3>

<p><a id="dt-xmldecl" name="dt-xmldecl"></a>XML documents may, and
should, begin with an <b>XML declaration</b> which specifies the
version of XML being used. For example, the following is a complete
XML document, <a href="#dt-wellformed">well-formed</a> but not <a
href="#dt-valid">valid</a>:</p>

<pre>
&lt;?xml version="1.0"?&gt;
&lt;greeting&gt;Hello, world!&lt;/greeting&gt;
</pre>

and so is this: 

<pre>
&lt;greeting&gt;Hello, world!&lt;/greeting&gt;
</pre>

<br />
<br />
 

<p>The version number "<code>1.0</code>" should be used to indicate
conformance to this version of this specification; it is an error
for a document to use the value "<code>1.0</code>" if it does not
conform to this version of this specification. It is the intent of
the XML working group to give later versions of this specification
numbers other than "<code>1.0</code>", but this intent does not
indicate a commitment to produce any future versions of XML, nor if
any are produced, to use any particular numbering scheme. Since
future versions are not ruled out, this construct is provided as a
means to allow the possibility of automatic version recognition,
should it become necessary. Processors may signal an error if they
receive documents labeled with versions they do not support.</p>

<p>The function of the markup in an XML document is to describe its
storage and logical structure and to associate attribute-value
pairs with its logical structures. XML provides a mechanism, the <a
href="#dt-doctype">document type declaration</a>, to define
constraints on the logical structure and to support the use of
predefined storage units. <a id="dt-valid" name="dt-valid"></a>An
XML document is <b>valid</b> if it has an associated document type
declaration and if the document complies with the constraints
expressed in it.</p>

<p>The document type declaration must appear before the first <a
href="#dt-element">element</a> in the document.</p>

<h5>Prolog</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-prolog" name="NT-prolog"></a>[22]   </td>
<td>prolog</td>
<td>   ::=   </td>
<td><a href="#NT-XMLDecl">XMLDecl</a>? <a href="#NT-Misc">Misc</a>*
(<a href="#NT-doctypedecl">doctypedecl</a> <a
href="#NT-Misc">Misc</a>*)?</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-XMLDecl" name="NT-XMLDecl"></a>[23]   </td>
<td>XMLDecl</td>
<td>   ::=   </td>
<td><a href="#NT-VersionInfo">VersionInfo</a> <a
href="#NT-EncodingDecl">EncodingDecl</a>? <a
href="#NT-SDDecl">SDDecl</a>? <a href="#NT-S">S</a>?</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-VersionInfo" name="NT-VersionInfo"></a>[24]   </td>
<td>VersionInfo</td>
<td>   ::=   </td>
<td><a href="#NT-S">S</a> 'version' <a href="#NT-Eq">Eq</a> (' <a
href="#NT-VersionNum">VersionNum</a> ' | " <a
href="#NT-VersionNum">VersionNum</a> ")</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-Eq" name="NT-Eq"></a>[25]   </td>
<td>Eq</td>
<td>   ::=   </td>
<td><a href="#NT-S">S</a>? '=' <a href="#NT-S">S</a>?</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-VersionNum" name="NT-VersionNum"></a>[26]   </td>
<td>VersionNum</td>
<td>   ::=   </td>
<td>([a-zA-Z0-9_.:] | '-')+</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-Misc" name="NT-Misc"></a>[27]   </td>
<td>Misc</td>
<td>   ::=   </td>
<td><a href="#NT-Comment">Comment</a> | <a href="#NT-PI">PI</a> |
<a href="#NT-S">S</a></td>
<td></td>
</tr>
</tbody>
</table>

<br />
<br />
 

<p><a id="dt-doctype" name="dt-doctype"></a>The XML <b>document
type declaration</b> contains or points to <a
href="#dt-markupdecl">markup declarations</a> that provide a
grammar for a class of documents. This grammar is known as a
document type definition, or <b>DTD</b>. The document type
declaration can point to an external subset (a special kind of <a
href="#dt-extent">external entity</a>) containing markup
declarations, or can contain the markup declarations directly in an
internal subset, or can do both. The DTD for a document consists of
both subsets taken together.</p>

<p><a id="dt-markupdecl" name="dt-markupdecl"></a> A <b>markup
declaration</b> is an <a href="#dt-eldecl">element type
declaration</a>, an <a href="#dt-attdecl">attribute-list
declaration</a>, an <a href="#dt-entdecl">entity declaration</a>,
or a <a href="#dt-notdecl">notation declaration</a>. These
declarations may be contained in whole or in part within <a
href="#dt-PE">parameter entities</a>, as described in the
well-formedness and validity constraints below. For fuller
information, see <a href="#sec-physical-struct">[]</a>.</p>

<h5>Document Type Definition</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-doctypedecl" name="NT-doctypedecl"></a>[28]   </td>
<td>doctypedecl</td>
<td>   ::=   </td>
<td>'&lt;!DOCTYPE' <a href="#NT-S">S</a> <a
href="#NT-Name">Name</a> (<a href="#NT-S">S</a> <a
href="#NT-ExternalID">ExternalID</a>)? <a href="#NT-S">S</a>? ('['
(<a href="#NT-markupdecl">markupdecl</a> | <a
href="#NT-PEReference">PEReference</a> | <a href="#NT-S">S</a>)*
']' <a href="#NT-S">S</a>?)? '&gt;'</td>
<td>[ VC: <a href="#vc-roottype"></a> ]</td>
</tr>

<tr valign="baseline">
<td><a id="NT-markupdecl" name="NT-markupdecl"></a>[29]   </td>
<td>markupdecl</td>
<td>   ::=   </td>
<td><a href="#NT-elementdecl">elementdecl</a> | <a
href="#NT-AttlistDecl">AttlistDecl</a> | <a
href="#NT-EntityDecl">EntityDecl</a> | <a
href="#NT-NotationDecl">NotationDecl</a> | <a href="#NT-PI">PI</a>
| <a href="#NT-Comment">Comment</a> </td>
<td>[ VC: <a href="#vc-PEinMarkupDecl"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td>[ WFC: <a href="#wfc-PEinInternalSubset"></a> ]</td>
</tr>
</tbody>
</table>

<p>The markup declarations may be made up in whole or in part of
the <a href="#dt-repltext">replacement text</a> of <a
href="#dt-PE">parameter entities</a>. The productions later in this
specification for individual nonterminals (<a
href="#NT-elementdecl">elementdecl</a>, <a
href="#NT-AttlistDecl">AttlistDecl</a>, and so on) describe the
declarations <i>after</i> all the parameter entities have been <a
href="#dt-include">included</a>.</p>

<a id="vc-roottype" name="vc-roottype"></a>
<p><b>Validity Constraint: Root Element Type</b></p>

Root Element Type 

<p>The <a href="#NT-Name">Name</a> in the document type declaration
must match the element type of the <a href="#dt-root">root
element</a>.</p>

<a id="vc-PEinMarkupDecl" name="vc-PEinMarkupDecl"></a>
<p><b>Validity Constraint: Proper Declaration/PE Nesting</b></p>

Proper Declaration/PE Nesting 

<p>Parameter-entity <a href="#dt-repltext">replacement text</a>
must be properly nested with markup declarations. That is to say,
if either the first character or the last character of a markup
declaration (<a href="#NT-markupdecl">markupdecl</a> above) is
contained in the replacement text for a <a
href="#dt-PERef">parameter-entity reference</a>, both must be
contained in the same replacement text.</p>

<a id="wfc-PEinInternalSubset" name="wfc-PEinInternalSubset"></a>
<p><b>Well Formedness Constraint: PEs in Internal Subset</b></p>

PEs in Internal Subset 

<p>In the internal DTD subset, <a href="#dt-PERef">parameter-entity
references</a> can occur only where markup declarations can occur,
not within markup declarations. (This does not apply to references
that occur in external parameter entities or to the external
subset.)</p>

<p>Like the internal subset, the external subset and any external
parameter entities referred to in the DTD must consist of a series
of complete markup declarations of the types allowed by the
non-terminal symbol <a href="#NT-markupdecl">markupdecl</a>,
interspersed with white space or <a
href="#dt-PERef">parameter-entity references</a>. However, portions
of the contents of the external subset or of external parameter
entities may conditionally be ignored by using the <a
href="#dt-cond-section">conditional section</a> construct; this is
not allowed in the internal subset.</p>

<h5>External Subset</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-extSubset" name="NT-extSubset"></a>[30]   </td>
<td>extSubset</td>
<td>   ::=   </td>
<td><a href="#NT-TextDecl">TextDecl</a>? <a
href="#NT-extSubsetDecl">extSubsetDecl</a></td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-extSubsetDecl"
name="NT-extSubsetDecl"></a>[31]   </td>
<td>extSubsetDecl</td>
<td>   ::=   </td>
<td>( <a href="#NT-markupdecl">markupdecl</a> | <a
href="#NT-conditionalSect">conditionalSect</a> | <a
href="#NT-PEReference">PEReference</a> | <a href="#NT-S">S</a>
)*</td>
<td></td>
</tr>
</tbody>
</table>

<br />
<br />
 

<p>The external subset and external parameter entities also differ
from the internal subset in that in them, <a
href="#dt-PERef">parameter-entity references</a> are permitted
<i>within</i> markup declarations, not only <i>between</i> markup
declarations.</p>

<p>An example of an XML document with a document type
declaration:</p>

<pre>
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE greeting SYSTEM "hello.dtd"&gt;
&lt;greeting&gt;Hello, world!&lt;/greeting&gt;
</pre>

The <a href="#dt-sysid">system identifier</a>
"<code>hello.dtd</code>" gives the URI of a DTD for the
document.<br />
<br />
 

<p>The declarations can also be given locally, as in this
example:</p>

<pre>
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE greeting [
  &lt;!ELEMENT greeting (#PCDATA)&gt;
]&gt;
&lt;greeting&gt;Hello, world!&lt;/greeting&gt;
</pre>

If both the external and internal subsets are used, the internal
subset is considered to occur before the external subset. This has
the effect that entity and attribute-list declarations in the
internal subset take precedence over those in the external subset.
<br />
<br />
 

<h3><a id="sec-rmd" name="sec-rmd"></a>2.9 Standalone Document
Declaration</h3>

<p>Markup declarations can affect the content of the document, as
passed from an <a href="#dt-xml-proc">XML processor</a> to an
application; examples are attribute defaults and entity
declarations. The standalone document declaration, which may appear
as a component of the XML declaration, signals whether or not there
are such declarations which appear external to the <a
href="#dt-docent">document entity</a>.</p>

<h5>Standalone Document Declaration</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-SDDecl" name="NT-SDDecl"></a>[32]   </td>
<td>SDDecl</td>
<td>   ::=   </td>
<td><a href="#NT-S">S</a> 'standalone' <a href="#NT-Eq">Eq</a>
(("'" ('yes' | 'no') "'") | ('"' ('yes' | 'no') '"'))</td>
<td>[ VC: <a href="#vc-check-rmd"></a> ]</td>
</tr>
</tbody>
</table>

<br />
<br />
 

<p>In a standalone document declaration, the value
"<code>yes</code>" indicates that there are no markup declarations
external to the <a href="#dt-docent">document entity</a> (either in
the DTD external subset, or in an external parameter entity
referenced from the internal subset) which affect the information
passed from the XML processor to the application. The value
"<code>no</code>" indicates that there are or may be such external
markup declarations. Note that the standalone document declaration
only denotes the presence of external <i>declarations</i>; the
presence, in a document, of references to external <i>entities</i>,
when those entities are internally declared, does not change its
standalone status.</p>

<p>If there are no external markup declarations, the standalone
document declaration has no meaning. If there are external markup
declarations but there is no standalone document declaration, the
value "<code>no</code>" is assumed.</p>

<p>Any XML document for which <code>standalone="no"</code> holds
can be converted algorithmically to a standalone document, which
may be desirable for some network delivery applications.</p>

<a id="vc-check-rmd" name="vc-check-rmd"></a>
<p><b>Validity Constraint: Standalone Document Declaration</b></p>

Standalone Document Declaration 

<p>The standalone document declaration must have the value
"<code>no</code>" if any external markup declarations contain
declarations of:</p>

<ul>
<li>
<p>attributes with <a href="#dt-default">default</a> values, if
elements to which these attributes apply appear in the document
without specifications of values for these attributes, or</p>
</li>

<li>
<p>entities (other than ), if <a href="#dt-entref">references</a>
to those entities appear in the document, or</p>
</li>

<li>
<p>attributes with values subject to <a
href="#AVNormalize">normalization</a>, where the attribute appears
in the document with a value which will change as a result of
normalization, or</p>
</li>

<li>
<p>element types with <a href="#dt-elemcontent">element
content</a>, if white space occurs directly within any instance of
those types.</p>
</li>
</ul>

<p>An example XML declaration with a standalone document
declaration:</p>

<pre>
&lt;?xml version="" standalone='yes'?&gt;
</pre>

<br />
<br />
 

<h3><a id="sec-white-space" name="sec-white-space"></a>2.10 White
Space Handling</h3>

<p>In editing XML documents, it is often convenient to use "white
space" (spaces, tabs, and blank lines, denoted by the nonterminal
<a href="#NT-S">S</a> in this specification) to set apart the
markup for greater readability. Such white space is typically not
intended for inclusion in the delivered version of the document. On
the other hand, "significant" white space that should be preserved
in the delivered version is common, for example in poetry and
source code.</p>

<p>An <a href="#dt-xml-proc">XML processor</a> must always pass all
characters in a document that are not markup through to the
application. A <a href="#dt-validating">validating XML
processor</a> must also inform the application which of these
characters constitute white space appearing in <a
href="#dt-elemcontent">element content</a>.</p>

<p>A special <a href="#dt-attr">attribute</a> named xml:space may
be attached to an element to signal an intention that in that
element, white space should be preserved by applications. In valid
documents, this attribute, like any other, must be <a
href="#dt-attdecl">declared</a> if it is used. When declared, it
must be given as an <a href="#dt-enumerated">enumerated type</a>
whose only possible values are "<code>default</code>" and
"<code>preserve</code>". For example:</p>

<pre>
    &lt;!ATTLIST poem   xml:space (default|preserve) 'preserve'&gt;
</pre>

<br />
<br />
 

<p>The value "<code>default</code>" signals that applications'
default white-space processing modes are acceptable for this
element; the value "<code>preserve</code>" indicates the intent
that applications preserve all the white space. This declared
intent is considered to apply to all elements within the content of
the element where it is specified, unless overriden with another
instance of the xml:space attribute.</p>

<p>The <a href="#dt-root">root element</a> of any document is
considered to have signaled no intentions as regards application
space handling, unless it provides a value for this attribute or
the attribute is declared with a default value.</p>

<h3><a id="sec-line-ends" name="sec-line-ends"></a>2.11 End-of-Line
Handling</h3>

<p>XML <a href="#dt-parsedent">parsed entities</a> are often stored
in computer files which, for editing convenience, are organized
into lines. These lines are typically separated by some combination
of the characters carriage-return (#xD) and line-feed (#xA).</p>

<p>To simplify the tasks of <a href="#dt-app">applications</a>,
wherever an external parsed entity or the literal entity value of
an internal parsed entity contains either the literal two-character
sequence "#xD#xA" or a standalone literal #xD, an <a
href="#dt-xml-proc">XML processor</a> must pass to the application
the single character #xA. (This behavior can conveniently be
produced by normalizing all line breaks to #xA on input, before
parsing.)</p>

<h3><a id="sec-lang-tag" name="sec-lang-tag"></a>2.12 Language
Identification</h3>

<p>In document processing, it is often useful to identify the
natural or formal language in which the content is written. A
special <a href="#dt-attr">attribute</a> named xml:lang may be
inserted in documents to specify the language used in the contents
and attribute values of any element in an XML document. In valid
documents, this attribute, like any other, must be <a
href="#dt-attdecl">declared</a> if it is used. The values of the
attribute are language identifiers as defined by <a
href="#RFC1766">[]</a>, "Tags for the Identification of
Languages":</p>

<h5>Language Identification</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-LanguageID" name="NT-LanguageID"></a>[33]   </td>
<td>LanguageID</td>
<td>   ::=   </td>
<td><a href="#NT-Langcode">Langcode</a> ('-' <a
href="#NT-Subcode">Subcode</a>)*</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-Langcode" name="NT-Langcode"></a>[34]   </td>
<td>Langcode</td>
<td>   ::=   </td>
<td><a href="#NT-ISO639Code">ISO639Code</a> | <a
href="#NT-IanaCode">IanaCode</a> | <a
href="#NT-UserCode">UserCode</a></td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-ISO639Code" name="NT-ISO639Code"></a>[35]   </td>
<td>ISO639Code</td>
<td>   ::=   </td>
<td>([a-z] | [A-Z]) ([a-z] | [A-Z])</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-IanaCode" name="NT-IanaCode"></a>[36]   </td>
<td>IanaCode</td>
<td>   ::=   </td>
<td>('i' | 'I') '-' ([a-z] | [A-Z])+</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-UserCode" name="NT-UserCode"></a>[37]   </td>
<td>UserCode</td>
<td>   ::=   </td>
<td>('x' | 'X') '-' ([a-z] | [A-Z])+</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-Subcode" name="NT-Subcode"></a>[38]   </td>
<td>Subcode</td>
<td>   ::=   </td>
<td>([a-z] | [A-Z])+</td>
<td></td>
</tr>
</tbody>
</table>

The <a href="#NT-Langcode">Langcode</a> may be any of the
following: 

<ul>
<li>
<p>a two-letter language code as defined by <a
href="#ISO639">[]</a>, "Codes for the representation of names of
languages"</p>
</li>

<li>
<p>a language identifier registered with the Internet Assigned
Numbers Authority <a href="#IANA">[]</a>; these begin with the
prefix "<code>i-</code>" (or "<code>I-</code>")</p>
</li>

<li>
<p>a language identifier assigned by the user, or agreed on between
parties in private use; these must begin with the prefix
"<code>x-</code>" or "<code>X-</code>" in order to ensure that they
do not conflict with names later standardized or registered with
IANA</p>
</li>
</ul>

<br />
<br />
 

<p>There may be any number of <a href="#NT-Subcode">Subcode</a>
segments; if the first subcode segment exists and the Subcode
consists of two letters, then it must be a country code from <a
href="#ISO3166">[]</a>, "Codes for the representation of names of
countries." If the first subcode consists of more than two letters,
it must be a subcode for the language in question registered with
IANA, unless the <a href="#NT-Langcode">Langcode</a> begins with
the prefix "<code>x-</code>" or "<code>X-</code>".</p>

<p>It is customary to give the language code in lower case, and the
country code (if any) in upper case. Note that these values, unlike
other names in XML documents, are case insensitive.</p>

<p>For example:</p>

<pre>
&lt;p xml:lang="en"&gt;The quick brown fox jumps over the lazy dog.&lt;/p&gt;
&lt;p xml:lang="en-GB"&gt;What colour is it?&lt;/p&gt;
&lt;p xml:lang="en-US"&gt;What color is it?&lt;/p&gt;
&lt;sp who="Faust" desc='leise' xml:lang="de"&gt;
  &lt;l&gt;Habe nun, ach! Philosophie,&lt;/l&gt;
  &lt;l&gt;Juristerei, und Medizin&lt;/l&gt;
  &lt;l&gt;und leider auch Theologie&lt;/l&gt;
  &lt;l&gt;durchaus studiert mit heißem Bemüh'n.&lt;/l&gt;
  &lt;/sp&gt;
</pre>

<br />
<br />
 

<p>The intent declared with xml:lang is considered to apply to all
attributes and content of the element where it is specified, unless
overridden with an instance of xml:lang on another element within
that content.</p>

<p>A simple declaration for xml:lang might take the form</p>

<pre>
xml:lang  NMTOKEN  #IMPLIED
</pre>

but specific default values may also be given, if appropriate. In a
collection of French poems for English students, with glosses and
notes in English, the xml:lang attribute might be declared this
way: 

<pre>
    &lt;!ATTLIST poem   xml:lang NMTOKEN 'fr'&gt;
    &lt;!ATTLIST gloss  xml:lang NMTOKEN 'en'&gt;
    &lt;!ATTLIST note   xml:lang NMTOKEN 'en'&gt;
</pre>

<br />
<br />
 

<h2><a id="sec-logical-struct" name="sec-logical-struct"></a>3
Logical Structures</h2>

<p><a id="dt-element" name="dt-element"></a>Each <a
href="#dt-xml-doc">XML document</a> contains one or more
<b>elements</b>, the boundaries of which are either delimited by <a
href="#dt-stag">start-tags</a> and <a href="#dt-etag">end-tags</a>,
or, for <a href="#dt-empty">empty</a> elements, by an <a
href="#dt-eetag">empty-element tag</a>. Each element has a type,
identified by name, sometimes called its "generic identifier" (GI),
and may have a set of attribute specifications. Each attribute
specification has a <a href="#dt-attrname">name</a> and a <a
href="#dt-attrval">value</a>.</p>

<h5>Element</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-element" name="NT-element"></a>[39]   </td>
<td>element</td>
<td>   ::=   </td>
<td><a href="#NT-EmptyElemTag">EmptyElemTag</a></td>
<td></td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td>| <a href="#NT-STag">STag</a> <a href="#NT-content">content</a>
<a href="#NT-ETag">ETag</a></td>
<td>[ WFC: <a href="#GIMatch"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td>[ VC: <a href="#elementvalid"></a> ]</td>
</tr>
</tbody>
</table>

<p>This specification does not constrain the semantics, use, or
(beyond syntax) names of the element types and attributes, except
that names beginning with a match to
<code>(('X'|'x')('M'|'m')('L'|'l'))</code> are reserved for
standardization in this or future versions of this
specification.</p>

<a id="GIMatch" name="GIMatch"></a>
<p><b>Well Formedness Constraint: Element Type Match</b></p>

Element Type Match 

<p>The <a href="#NT-Name">Name</a> in an element's end-tag must
match the element type in the start-tag.</p>

<a id="elementvalid" name="elementvalid"></a>
<p><b>Validity Constraint: Element Valid</b></p>

Element Valid 

<p>An element is valid if there is a declaration matching <a
href="#NT-elementdecl">elementdecl</a> where the <a
href="#NT-Name">Name</a> matches the element type, and one of the
following holds:</p>

<ol>
<li>
<p>The declaration matches EMPTY and the element has no <a
href="#dt-content">content</a>.</p>
</li>

<li>
<p>The declaration matches <a href="#NT-children">children</a> and
the sequence of <a href="#dt-parentchild">child elements</a>
belongs to the language generated by the regular expression in the
content model, with optional white space (characters matching the
nonterminal <a href="#NT-S">S</a>) between each pair of child
elements.</p>
</li>

<li>
<p>The declaration matches <a href="#NT-Mixed">Mixed</a> and the
content consists of <a href="#dt-chardata">character data</a> and
<a href="#dt-parentchild">child elements</a> whose types match
names in the content model.</p>
</li>

<li>
<p>The declaration matches ANY, and the types of any <a
href="#dt-parentchild">child elements</a> have been declared.</p>
</li>
</ol>

<h3><a id="sec-starttags" name="sec-starttags"></a>3.1 Start-Tags,
End-Tags, and Empty-Element Tags</h3>

<p><a id="dt-stag" name="dt-stag"></a>The beginning of every
non-empty XML element is marked by a <b>start-tag</b>.</p>

<h5>Start-tag</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-STag" name="NT-STag"></a>[40]   </td>
<td>STag</td>
<td>   ::=   </td>
<td>'&lt;' <a href="#NT-Name">Name</a> (<a href="#NT-S">S</a> <a
href="#NT-Attribute">Attribute</a>)* <a href="#NT-S">S</a>?
'&gt;'</td>
<td>[ WFC: <a href="#uniqattspec"></a> ]</td>
</tr>

<tr valign="baseline">
<td><a id="NT-Attribute" name="NT-Attribute"></a>[41]   </td>
<td>Attribute</td>
<td>   ::=   </td>
<td><a href="#NT-Name">Name</a> <a href="#NT-Eq">Eq</a> <a
href="#NT-AttValue">AttValue</a></td>
<td>[ VC: <a href="#ValueType"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td>[ WFC: <a href="#NoExternalRefs"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td>[ WFC: <a href="#CleanAttrVals"></a> ]</td>
</tr>
</tbody>
</table>

The <a href="#NT-Name">Name</a> in the start- and end-tags gives
the element's <b>type</b>. <a id="dt-attr" name="dt-attr"></a> The
<a href="#NT-Name">Name</a>-<a href="#NT-AttValue">AttValue</a>
pairs are referred to as the <b>attribute specifications</b> of the
element, <a id="dt-attrname" name="dt-attrname"></a>with the <a
href="#NT-Name">Name</a> in each pair referred to as the
<b>attribute name</b> and <a id="dt-attrval"
name="dt-attrval"></a>the content of the <a
href="#NT-AttValue">AttValue</a> (the text between the
<code>'</code> or <code>"</code> delimiters) as the <b>attribute
value</b>. <br />
<br />
 <a id="uniqattspec" name="uniqattspec"></a>
<p><b>Well Formedness Constraint: Unique Att Spec</b></p>

Unique Att Spec 

<p>No attribute name may appear more than once in the same
start-tag or empty-element tag.</p>

<a id="ValueType" name="ValueType"></a>
<p><b>Validity Constraint: Attribute Value Type</b></p>

Attribute Value Type 

<p>The attribute must have been declared; the value must be of the
type declared for it. (For attribute types, see <a
href="#attdecls">[]</a>.)</p>

<a id="NoExternalRefs" name="NoExternalRefs"></a>
<p><b>Well Formedness Constraint: No External Entity
References</b></p>

No External Entity References 

<p>Attribute values cannot contain direct or indirect entity
references to external entities.</p>

<a id="CleanAttrVals" name="CleanAttrVals"></a>
<p><b>Well Formedness Constraint: No &lt; in Attribute
Values</b></p>

No <code>&lt;</code> in Attribute Values 

<p>The <a href="#dt-repltext">replacement text</a> of any entity
referred to directly or indirectly in an attribute value (other
than "<code>&amp;lt;</code>") must not contain a
<code>&lt;</code>.</p>

<p>An example of a start-tag:</p>

<pre>
&lt;termdef id="dt-dog" term="dog"&gt;
</pre>

<br />
<br />
 

<p><a id="dt-etag" name="dt-etag"></a>The end of every element that
begins with a start-tag must be marked by an <b>end-tag</b>
containing a name that echoes the element's type as given in the
start-tag:</p>

<h5>End-tag</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-ETag" name="NT-ETag"></a>[42]   </td>
<td>ETag</td>
<td>   ::=   </td>
<td>'&lt;/' <a href="#NT-Name">Name</a> <a href="#NT-S">S</a>?
'&gt;'</td>
<td></td>
</tr>
</tbody>
</table>

<br />
<br />
 

<p>An example of an end-tag:</p>

<pre>
&lt;/termdef&gt;
</pre>

<br />
<br />
 

<p><a id="dt-content" name="dt-content"></a>The <a
href="#dt-text">text</a> between the start-tag and end-tag is
called the element's <b>content</b>:</p>

<h5>Content of Elements</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-content" name="NT-content"></a>[43]   </td>
<td>content</td>
<td>   ::=   </td>
<td>(<a href="#NT-element">element</a> | <a
href="#NT-CharData">CharData</a> | <a
href="#NT-Reference">Reference</a> | <a
href="#NT-CDSect">CDSect</a> | <a href="#NT-PI">PI</a> | <a
href="#NT-Comment">Comment</a>)*</td>
<td></td>
</tr>
</tbody>
</table>

<br />
<br />
 

<p><a id="dt-empty" name="dt-empty"></a>If an element is
<b>empty</b>, it must be represented either by a start-tag
immediately followed by an end-tag or by an empty-element tag. <a
id="dt-eetag" name="dt-eetag"></a>An <b>empty-element tag</b> takes
a special form:</p>

<h5>Tags for Empty Elements</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-EmptyElemTag" name="NT-EmptyElemTag"></a>[44]   </td>
<td>EmptyElemTag</td>
<td>   ::=   </td>
<td>'&lt;' <a href="#NT-Name">Name</a> (<a href="#NT-S">S</a> <a
href="#NT-Attribute">Attribute</a>)* <a href="#NT-S">S</a>?
'/&gt;'</td>
<td>[ WFC: <a href="#uniqattspec"></a> ]</td>
</tr>
</tbody>
</table>

<br />
<br />
 

<p>Empty-element tags may be used for any element which has no
content, whether or not it is declared using the keyword EMPTY. <a
href="#dt-interop">For interoperability</a>, the empty-element tag
must be used, and can only be used, for elements which are <a
href="#dt-eldecl">declared</a> EMPTY.</p>

<p>Examples of empty elements:</p>

<pre>
&lt;IMG align="left"
 src="http://www.w3.org/Icons/WWW/w3c_home" /&gt;
&lt;br&gt;&lt;/br&gt;
&lt;br/&gt;
</pre>

<br />
<br />
 

<h3><a id="elemdecls" name="elemdecls"></a>3.2 Element Type
Declarations</h3>

<p>The <a href="#dt-element">element</a> structure of an <a
href="#dt-xml-doc">XML document</a> may, for <a
href="#dt-valid">validation</a> purposes, be constrained using
element type and attribute-list declarations. An element type
declaration constrains the element's <a
href="#dt-content">content</a>.</p>

<p>Element type declarations often constrain which element types
can appear as <a href="#dt-parentchild">children</a> of the
element. At user option, an XML processor may issue a warning when
a declaration mentions an element type for which no declaration is
provided, but this is not an error.</p>

<p><a id="dt-eldecl" name="dt-eldecl"></a>An <b>element type
declaration</b> takes the form:</p>

<h5>Element Type Declaration</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-elementdecl" name="NT-elementdecl"></a>[45]   </td>
<td>elementdecl</td>
<td>   ::=   </td>
<td>'&lt;!ELEMENT' <a href="#NT-S">S</a> <a
href="#NT-Name">Name</a> <a href="#NT-S">S</a> <a
href="#NT-contentspec">contentspec</a> <a href="#NT-S">S</a>?
'&gt;'</td>
<td>[ VC: <a href="#EDUnique"></a> ]</td>
</tr>

<tr valign="baseline">
<td><a id="NT-contentspec" name="NT-contentspec"></a>[46]   </td>
<td>contentspec</td>
<td>   ::=   </td>
<td>'EMPTY' | 'ANY' | <a href="#NT-Mixed">Mixed</a> | <a
href="#NT-children">children</a> </td>
<td></td>
</tr>
</tbody>
</table>

where the <a href="#NT-Name">Name</a> gives the element type being
declared. <br />
<br />
 <a id="EDUnique" name="EDUnique"></a>
<p><b>Validity Constraint: Unique Element Type Declaration</b></p>

Unique Element Type Declaration 

<p>No element type may be declared more than once.</p>

<p>Examples of element type declarations:</p>

<pre>
&lt;!ELEMENT br EMPTY&gt;
&lt;!ELEMENT p (#PCDATA|emph)* &gt;
&lt;!ELEMENT %name.para; %content.para; &gt;
&lt;!ELEMENT container ANY&gt;
</pre>

<br />
<br />
 

<h4><a id="sec-element-content"
name="sec-element-content"></a>3.2.1 Element Content</h4>

<p><a id="dt-elemcontent" name="dt-elemcontent"></a>An element <a
href="#dt-stag">type</a> has <b>element content</b> when elements
of that type must contain only <a href="#dt-parentchild">child</a>
elements (no character data), optionally separated by white space
(characters matching the nonterminal <a href="#NT-S">S</a>). In
this case, the constraint includes a content model, a simple
grammar governing the allowed types of the child elements and the
order in which they are allowed to appear. The grammar is built on
content particles (<a href="#NT-cp">cp</a>s), which consist of
names, choice lists of content particles, or sequence lists of
content particles:</p>

<h5>Element-content Models</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-children" name="NT-children"></a>[47]   </td>
<td>children</td>
<td>   ::=   </td>
<td>(<a href="#NT-choice">choice</a> | <a href="#NT-seq">seq</a>)
('?' | '*' | '+')?</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-cp" name="NT-cp"></a>[48]   </td>
<td>cp</td>
<td>   ::=   </td>
<td>(<a href="#NT-Name">Name</a> | <a href="#NT-choice">choice</a>
| <a href="#NT-seq">seq</a>) ('?' | '*' | '+')?</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-choice" name="NT-choice"></a>[49]   </td>
<td>choice</td>
<td>   ::=   </td>
<td>'(' <a href="#NT-S">S</a>? cp ( <a href="#NT-S">S</a>? '|' <a
href="#NT-S">S</a>? <a href="#NT-cp">cp</a> )* <a
href="#NT-S">S</a>? ')'</td>
<td>[ VC: <a href="#vc-PEinGroup"></a> ]</td>
</tr>

<tr valign="baseline">
<td><a id="NT-seq" name="NT-seq"></a>[50]   </td>
<td>seq</td>
<td>   ::=   </td>
<td>'(' <a href="#NT-S">S</a>? cp ( <a href="#NT-S">S</a>? ',' <a
href="#NT-S">S</a>? <a href="#NT-cp">cp</a> )* <a
href="#NT-S">S</a>? ')'</td>
<td>[ VC: <a href="#vc-PEinGroup"></a> ]</td>
</tr>
</tbody>
</table>

where each <a href="#NT-Name">Name</a> is the type of an element
which may appear as a <a href="#dt-parentchild">child</a>. Any
content particle in a choice list may appear in the <a
href="#dt-elemcontent">element content</a> at the location where
the choice list appears in the grammar; content particles occurring
in a sequence list must each appear in the <a
href="#dt-elemcontent">element content</a> in the order given in
the list. The optional character following a name or list governs
whether the element or the content particles in the list may occur
one or more (<code>+</code>), zero or more (<code>*</code>), or
zero or one times (<code>?</code>). The absence of such an operator
means that the element or content particle must appear exactly
once. This syntax and meaning are identical to those used in the
productions in this specification.<br />
<br />
 

<p>The content of an element matches a content model if and only if
it is possible to trace out a path through the content model,
obeying the sequence, choice, and repetition operators and matching
each element in the content against an element type in the content
model. <a href="#dt-compat">For compatibility</a>, it is an error
if an element in the document can match more than one occurrence of
an element type in the content model. For more information, see <a
href="#determinism">[]</a>.</p>

<a id="vc-PEinGroup" name="vc-PEinGroup"></a>
<p><b>Validity Constraint: Proper Group/PE Nesting</b></p>

Proper Group/PE Nesting 

<p>Parameter-entity <a href="#dt-repltext">replacement text</a>
must be properly nested with parenthetized groups. That is to say,
if either of the opening or closing parentheses in a <a
href="#NT-choice">choice</a>, <a href="#NT-seq">seq</a>, or <a
href="#NT-Mixed">Mixed</a> construct is contained in the
replacement text for a <a href="#dt-PERef">parameter entity</a>,
both must be contained in the same replacement text.</p>

<p><a href="#dt-interop">For interoperability</a>, if a
parameter-entity reference appears in a <a
href="#NT-choice">choice</a>, <a href="#NT-seq">seq</a>, or <a
href="#NT-Mixed">Mixed</a> construct, its replacement text should
not be empty, and neither the first nor last non-blank character of
the replacement text should be a connector (<code>|</code> or
<code>,</code>).</p>

<p>Examples of element-content models:</p>

<pre>
&lt;!ELEMENT spec (front, body, back?)&gt;
&lt;!ELEMENT div1 (head, (p | list | note)*, div2*)&gt;
&lt;!ELEMENT dictionary-body (%div.mix; | %dict.mix;)*&gt;
</pre>

<br />
<br />
 

<h4><a id="sec-mixed-content" name="sec-mixed-content"></a>3.2.2
Mixed Content</h4>

<p><a id="dt-mixed" name="dt-mixed"></a>An element <a
href="#dt-stag">type</a> has <b>mixed content</b> when elements of
that type may contain character data, optionally interspersed with
<a href="#dt-parentchild">child</a> elements. In this case, the
types of the child elements may be constrained, but not their order
or their number of occurrences:</p>

<h5>Mixed-content Declaration</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-Mixed" name="NT-Mixed"></a>[51]   </td>
<td>Mixed</td>
<td>   ::=   </td>
<td>'(' <a href="#NT-S">S</a>? '#PCDATA' (<a href="#NT-S">S</a>?
'|' <a href="#NT-S">S</a>? <a href="#NT-Name">Name</a>)* <a
href="#NT-S">S</a>? ')*'</td>
<td></td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td>| '(' <a href="#NT-S">S</a>? '#PCDATA' <a href="#NT-S">S</a>?
')'</td>
<td>[ VC: <a href="#vc-PEinGroup"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td>[ VC: <a href="#vc-MixedChildrenUnique"></a> ]</td>
</tr>
</tbody>
</table>

where the <a href="#NT-Name">Name</a>s give the types of elements
that may appear as children. <br />
<br />
 <a id="vc-MixedChildrenUnique" name="vc-MixedChildrenUnique"></a>
<p><b>Validity Constraint: No Duplicate Types</b></p>

No Duplicate Types 

<p>The same name must not appear more than once in a single
mixed-content declaration.</p>

<p>Examples of mixed content declarations:</p>

<pre>
&lt;!ELEMENT p (#PCDATA|a|ul|b|i|em)*&gt;
&lt;!ELEMENT p (#PCDATA | %font; | %phrase; | %special; | %form;)* &gt;
&lt;!ELEMENT b (#PCDATA)&gt;
</pre>

<br />
<br />
 

<h3><a id="attdecls" name="attdecls"></a>3.3 Attribute-List
Declarations</h3>

<p><a href="#dt-attr">Attributes</a> are used to associate
name-value pairs with <a href="#dt-element">elements</a>. Attribute
specifications may appear only within <a
href="#dt-stag">start-tags</a> and <a
href="#dt-eetag">empty-element tags</a>; thus, the productions used
to recognize them appear in <a href="#sec-starttags">[]</a>.
Attribute-list declarations may be used:</p>

<ul>
<li>
<p>To define the set of attributes pertaining to a given element
type.</p>
</li>

<li>
<p>To establish type constraints for these attributes.</p>
</li>

<li>
<p>To provide <a href="#dt-default">default values</a> for
attributes.</p>
</li>
</ul>

<br />
<br />
 

<p><a id="dt-attdecl" name="dt-attdecl"></a> <b>Attribute-list
declarations</b> specify the name, data type, and default value (if
any) of each attribute associated with a given element type:</p>

<h5>Attribute-list Declaration</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-AttlistDecl" name="NT-AttlistDecl"></a>[52]   </td>
<td>AttlistDecl</td>
<td>   ::=   </td>
<td>'&lt;!ATTLIST' <a href="#NT-S">S</a> <a
href="#NT-Name">Name</a> <a href="#NT-AttDef">AttDef</a>* <a
href="#NT-S">S</a>? '&gt;'</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-AttDef" name="NT-AttDef"></a>[53]   </td>
<td>AttDef</td>
<td>   ::=   </td>
<td><a href="#NT-S">S</a> <a href="#NT-Name">Name</a> <a
href="#NT-S">S</a> <a href="#NT-AttType">AttType</a> <a
href="#NT-S">S</a> <a href="#NT-DefaultDecl">DefaultDecl</a></td>
<td></td>
</tr>
</tbody>
</table>

The <a href="#NT-Name">Name</a> in the <a
href="#NT-AttlistDecl">AttlistDecl</a> rule is the type of an
element. At user option, an XML processor may issue a warning if
attributes are declared for an element type not itself declared,
but this is not an error. The <a href="#NT-Name">Name</a> in the <a
href="#NT-AttDef">AttDef</a> rule is the name of the
attribute.<br />
<br />
 

<p>When more than one <a href="#NT-AttlistDecl">AttlistDecl</a> is
provided for a given element type, the contents of all those
provided are merged. When more than one definition is provided for
the same attribute of a given element type, the first declaration
is binding and later declarations are ignored. <a
href="#dt-interop">For interoperability,</a> writers of DTDs may
choose to provide at most one attribute-list declaration for a
given element type, at most one attribute definition for a given
attribute name, and at least one attribute definition in each
attribute-list declaration. For interoperability, an XML processor
may at user option issue a warning when more than one
attribute-list declaration is provided for a given element type, or
more than one attribute definition is provided for a given
attribute, but this is not an error.</p>

<h4><a id="sec-attribute-types"
name="sec-attribute-types"></a>3.3.1 Attribute Types</h4>

<p>XML attribute types are of three kinds: a string type, a set of
tokenized types, and enumerated types. The string type may take any
literal string as a value; the tokenized types have varying lexical
and semantic constraints, as noted:</p>

<h5>Attribute Types</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-AttType" name="NT-AttType"></a>[54]   </td>
<td>AttType</td>
<td>   ::=   </td>
<td><a href="#NT-StringType">StringType</a> | <a
href="#NT-TokenizedType">TokenizedType</a> | <a
href="#NT-EnumeratedType">EnumeratedType</a> </td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-StringType" name="NT-StringType"></a>[55]   </td>
<td>StringType</td>
<td>   ::=   </td>
<td>'CDATA'</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-TokenizedType"
name="NT-TokenizedType"></a>[56]   </td>
<td>TokenizedType</td>
<td>   ::=   </td>
<td>'ID'</td>
<td>[ VC: <a href="#id"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td>[ VC: <a href="#one-id-per-el"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td>[ VC: <a href="#id-default"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td>| 'IDREF'</td>
<td>[ VC: <a href="#idref"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td>| 'IDREFS'</td>
<td>[ VC: <a href="#idref"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td>| 'ENTITY'</td>
<td>[ VC: <a href="#entname"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td>| 'ENTITIES'</td>
<td>[ VC: <a href="#entname"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td>| 'NMTOKEN'</td>
<td>[ VC: <a href="#nmtok"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td>| 'NMTOKENS'</td>
<td>[ VC: <a href="#nmtok"></a> ]</td>
</tr>
</tbody>
</table>

<br />
<br />
 <a id="id" name="id"></a>
<p><b>Validity Constraint: ID</b></p>

ID 

<p>Values of type ID must match the <a href="#NT-Name">Name</a>
production. A name must not appear more than once in an XML
document as a value of this type; i.e., ID values must uniquely
identify the elements which bear them.</p>

<a id="one-id-per-el" name="one-id-per-el"></a>
<p><b>Validity Constraint: One ID per Element Type</b></p>

One ID per Element Type 

<p>No element type may have more than one ID attribute
specified.</p>

<a id="id-default" name="id-default"></a>
<p><b>Validity Constraint: ID Attribute Default</b></p>

ID Attribute Default 

<p>An ID attribute must have a declared default of #IMPLIED or
#REQUIRED.</p>

<a id="idref" name="idref"></a>
<p><b>Validity Constraint: IDREF</b></p>

IDREF 

<p>Values of type IDREF must match the <a href="#NT-Name">Name</a>
production, and values of type IDREFS must match <a
href="#NT-Names">Names</a>; each <a href="#NT-Name">Name</a> must
match the value of an ID attribute on some element in the XML
document; i.e. IDREF values must match the value of some ID
attribute.</p>

<a id="entname" name="entname"></a>
<p><b>Validity Constraint: Entity Name</b></p>

Entity Name 

<p>Values of type ENTITY must match the <a href="#NT-Name">Name</a>
production, values of type ENTITIES must match <a
href="#NT-Names">Names</a>; each <a href="#NT-Name">Name</a> must
match the name of an <a href="#dt-unparsed">unparsed entity</a>
declared in the <a href="#dt-doctype">DTD</a>.</p>

<a id="nmtok" name="nmtok"></a>
<p><b>Validity Constraint: Name Token</b></p>

Name Token 

<p>Values of type NMTOKEN must match the <a
href="#NT-Nmtoken">Nmtoken</a> production; values of type NMTOKENS
must match <a href="#NT-Nmtokens">Nmtokens</a>.</p>

<p><a id="dt-enumerated" name="dt-enumerated"></a><b>Enumerated
attributes</b> can take one of a list of values provided in the
declaration. There are two kinds of enumerated types:</p>

<h5>Enumerated Attribute Types</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-EnumeratedType"
name="NT-EnumeratedType"></a>[57]   </td>
<td>EnumeratedType</td>
<td>   ::=   </td>
<td><a href="#NT-NotationType">NotationType</a> | <a
href="#NT-Enumeration">Enumeration</a> </td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-NotationType" name="NT-NotationType"></a>[58]   </td>
<td>NotationType</td>
<td>   ::=   </td>
<td>'NOTATION' <a href="#NT-S">S</a> '(' <a href="#NT-S">S</a>? <a
href="#NT-Name">Name</a> (<a href="#NT-S">S</a>? '|' <a
href="#NT-S">S</a>? <a href="#NT-Name">Name</a>)* <a
href="#NT-S">S</a>? ')'</td>
<td>[ VC: <a href="#notatn"></a> ]</td>
</tr>

<tr valign="baseline">
<td><a id="NT-Enumeration" name="NT-Enumeration"></a>[59]   </td>
<td>Enumeration</td>
<td>   ::=   </td>
<td>'(' <a href="#NT-S">S</a>? <a href="#NT-Nmtoken">Nmtoken</a>
(<a href="#NT-S">S</a>? '|' <a href="#NT-S">S</a>? <a
href="#NT-Nmtoken">Nmtoken</a>)* <a href="#NT-S">S</a>? ')'</td>
<td>[ VC: <a href="#enum"></a> ]</td>
</tr>
</tbody>
</table>

A NOTATION attribute identifies a <a
href="#dt-notation">notation</a>, declared in the DTD with
associated system and/or public identifiers, to be used in
interpreting the element to which the attribute is attached. <br />
<br />
 <a id="notatn" name="notatn"></a>
<p><b>Validity Constraint: Notation Attributes</b></p>

Notation Attributes 

<p>Values of this type must match one of the <a
href="#Notations">notation</a> names included in the declaration;
all notation names in the declaration must be declared.</p>

<a id="enum" name="enum"></a>
<p><b>Validity Constraint: Enumeration</b></p>

Enumeration 

<p>Values of this type must match one of the <a
href="#NT-Nmtoken">Nmtoken</a> tokens in the declaration.</p>

<p><a href="#dt-interop">For interoperability,</a> the same <a
href="#NT-Nmtoken">Nmtoken</a> should not occur more than once in
the enumerated attribute types of a single element type.</p>

<h4><a id="sec-attr-defaults" name="sec-attr-defaults"></a>3.3.2
Attribute Defaults</h4>

<p>An <a href="#dt-attdecl">attribute declaration</a> provides
information on whether the attribute's presence is required, and if
not, how an XML processor should react if a declared attribute is
absent in a document.</p>

<h5>Attribute Defaults</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-DefaultDecl" name="NT-DefaultDecl"></a>[60]   </td>
<td>DefaultDecl</td>
<td>   ::=   </td>
<td>'#REQUIRED' |'#IMPLIED'</td>
<td></td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td>| (('#FIXED' S)? <a href="#NT-AttValue">AttValue</a>)</td>
<td>[ VC: <a href="#RequiredAttr"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td>[ VC: <a href="#defattrvalid"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td>[ WFC: <a href="#CleanAttrVals"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td>[ VC: <a href="#FixedAttr"></a> ]</td>
</tr>
</tbody>
</table>

<br />
<br />
 

<p>In an attribute declaration, #REQUIRED means that the attribute
must always be provided, #IMPLIED that no default value is
provided. <a id="dt-default" name="dt-default"></a>If the
declaration is neither #REQUIRED nor #IMPLIED, then the <a
href="#NT-AttValue">AttValue</a> value contains the declared
<b>default</b> value; the #FIXED keyword states that the attribute
must always have the default value. If a default value is declared,
when an XML processor encounters an omitted attribute, it is to
behave as though the attribute were present with the declared
default value.</p>

<a id="RequiredAttr" name="RequiredAttr"></a>
<p><b>Validity Constraint: Required Attribute</b></p>

Required Attribute 

<p>If the default declaration is the keyword #REQUIRED, then the
attribute must be specified for all elements of the type in the
attribute-list declaration.</p>

<a id="defattrvalid" name="defattrvalid"></a>
<p><b>Validity Constraint: Attribute Default Legal</b></p>

Attribute Default Legal 

<p>The declared default value must meet the lexical constraints of
the declared attribute type.</p>

<a id="FixedAttr" name="FixedAttr"></a>
<p><b>Validity Constraint: Fixed Attribute Default</b></p>

Fixed Attribute Default 

<p>If an attribute has a default value declared with the #FIXED
keyword, instances of that attribute must match the default
value.</p>

<p>Examples of attribute-list declarations:</p>

<pre>
&lt;!ATTLIST termdef
          id      ID      #REQUIRED
          name    CDATA   #IMPLIED&gt;
&lt;!ATTLIST list
          type    (bullets|ordered|glossary)  "ordered"&gt;
&lt;!ATTLIST form
          method  CDATA   #FIXED "POST"&gt;
</pre>

<br />
<br />
 

<h4><a id="AVNormalize" name="AVNormalize"></a>3.3.3
Attribute-Value Normalization</h4>

<p>Before the value of an attribute is passed to the application or
checked for validity, the XML processor must normalize it as
follows:</p>

<ul>
<li>
<p>a character reference is processed by appending the referenced
character to the attribute value</p>
</li>

<li>
<p>an entity reference is processed by recursively processing the
replacement text of the entity</p>
</li>

<li>
<p>a whitespace character (#x20, #xD, #xA, #x9) is processed by
appending #x20 to the normalized value, except that only a single
#x20 is appended for a "#xD#xA" sequence that is part of an
external parsed entity or the literal entity value of an internal
parsed entity</p>
</li>

<li>
<p>other characters are processed by appending them to the
normalized value</p>
</li>
</ul>

<br />
<br />
 

<p>If the declared value is not CDATA, then the XML processor must
further process the normalized attribute value by discarding any
leading and trailing space (#x20) characters, and by replacing
sequences of space (#x20) characters by a single space (#x20)
character.</p>

<p>All attributes for which no declaration has been read should be
treated by a non-validating parser as if declared CDATA.</p>

<h3><a id="sec-condition-sect" name="sec-condition-sect"></a>3.4
Conditional Sections</h3>

<p><a id="dt-cond-section" name="dt-cond-section"></a>
<b>Conditional sections</b> are portions of the <a
href="#dt-doctype">document type declaration external subset</a>
which are included in, or excluded from, the logical structure of
the DTD based on the keyword which governs them.</p>

<h5>Conditional Section</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-conditionalSect"
name="NT-conditionalSect"></a>[61]   </td>
<td>conditionalSect</td>
<td>   ::=   </td>
<td><a href="#NT-includeSect">includeSect</a> | <a
href="#NT-ignoreSect">ignoreSect</a> </td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-includeSect" name="NT-includeSect"></a>[62]   </td>
<td>includeSect</td>
<td>   ::=   </td>
<td>'&lt;![' S? 'INCLUDE' S? '[' <a
href="#NT-extSubsetDecl">extSubsetDecl</a> ']]&gt;'</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-ignoreSect" name="NT-ignoreSect"></a>[63]   </td>
<td>ignoreSect</td>
<td>   ::=   </td>
<td>'&lt;![' S? 'IGNORE' S? '[' <a
href="#NT-ignoreSectContents">ignoreSectContents</a>* ']]&gt;'</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-ignoreSectContents"
name="NT-ignoreSectContents"></a>[64]   </td>
<td>ignoreSectContents</td>
<td>   ::=   </td>
<td><a href="#NT-Ignore">Ignore</a> ('&lt;![' <a
href="#NT-ignoreSectContents">ignoreSectContents</a> ']]&gt;' <a
href="#NT-Ignore">Ignore</a>)*</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-Ignore" name="NT-Ignore"></a>[65]   </td>
<td>Ignore</td>
<td>   ::=   </td>
<td><a href="#NT-Char">Char</a>* - (<a href="#NT-Char">Char</a>*
('&lt;![' | ']]&gt;') <a href="#NT-Char">Char</a>*)</td>
<td></td>
</tr>
</tbody>
</table>

<br />
<br />
 

<p>Like the internal and external DTD subsets, a conditional
section may contain one or more complete declarations, comments,
processing instructions, or nested conditional sections,
intermingled with white space.</p>

<p>If the keyword of the conditional section is INCLUDE, then the
contents of the conditional section are part of the DTD. If the
keyword of the conditional section is IGNORE, then the contents of
the conditional section are not logically part of the DTD. Note
that for reliable parsing, the contents of even ignored conditional
sections must be read in order to detect nested conditional
sections and ensure that the end of the outermost (ignored)
conditional section is properly detected. If a conditional section
with a keyword of INCLUDE occurs within a larger conditional
section with a keyword of IGNORE, both the outer and the inner
conditional sections are ignored.</p>

<p>If the keyword of the conditional section is a parameter-entity
reference, the parameter entity must be replaced by its content
before the processor decides whether to include or ignore the
conditional section.</p>

<p>An example:</p>

<pre>
&lt;!ENTITY % draft 'INCLUDE' &gt;
&lt;!ENTITY % final 'IGNORE' &gt;
 
&lt;![%draft;[
&lt;!ELEMENT book (comments*, title, body, supplements?)&gt;
]]&gt;
&lt;![%final;[
&lt;!ELEMENT book (title, body, supplements?)&gt;
]]&gt;
</pre>

<br />
<br />
 

<h2><a id="sec-physical-struct" name="sec-physical-struct"></a>4
Physical Structures</h2>

<p><a id="dt-entity" name="dt-entity"></a>An XML document may
consist of one or many storage units. These are called
<b>entities</b>; they all have <b>content</b> and are all (except
for the document entity, see below, and the <a
href="#dt-doctype">external DTD subset</a>) identified by
<b>name</b>. Each XML document has one entity called the <a
href="#dt-docent">document entity</a>, which serves as the starting
point for the <a href="#dt-xml-proc">XML processor</a> and may
contain the whole document.</p>

<p>Entities may be either parsed or unparsed. <a id="dt-parsedent"
name="dt-parsedent"></a>A <b>parsed entity's</b> contents are
referred to as its <a href="#dt-repltext">replacement text</a>;
this <a href="#dt-text">text</a> is considered an integral part of
the document.</p>

<p><a id="dt-unparsed" name="dt-unparsed"></a>An <b>unparsed
entity</b> is a resource whose contents may or may not be <a
href="#dt-text">text</a>, and if text, may not be XML. Each
unparsed entity has an associated <a
href="#dt-notation">notation</a>, identified by name. Beyond a
requirement that an XML processor make the identifiers for the
entity and notation available to the application, XML places no
constraints on the contents of unparsed entities.</p>

<p>Parsed entities are invoked by name using entity references;
unparsed entities by name, given in the value of ENTITY or ENTITIES
attributes.</p>

<p><a id="gen-entity" name="gen-entity"></a><b>General entities</b>
are entities for use within the document content. In this
specification, general entities are sometimes referred to with the
unqualified term <i>entity</i> when this leads to no ambiguity. <a
id="dt-PE" name="dt-PE"></a>Parameter entities are parsed entities
for use within the DTD. These two types of entities use different
forms of reference and are recognized in different contexts.
Furthermore, they occupy different namespaces; a parameter entity
and a general entity with the same name are two distinct
entities.</p>

<h3><a id="sec-references" name="sec-references"></a>4.1 Character
and Entity References</h3>

<p><a id="dt-charref" name="dt-charref"></a> A <b>character
reference</b> refers to a specific character in the ISO/IEC 10646
character set, for example one not directly accessible from
available input devices.</p>

<h5>Character Reference</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-CharRef" name="NT-CharRef"></a>[66]   </td>
<td>CharRef</td>
<td>   ::=   </td>
<td>'&amp;#' [0-9]+ ';'</td>
<td></td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td>| '' [0-9a-fA-F]+ ';'</td>
<td>[ WFC: <a href="#wf-Legalchar"></a> ]</td>
</tr>
</tbody>
</table>

<a id="wf-Legalchar" name="wf-Legalchar"></a>
<p><b>Well Formedness Constraint: Legal Character</b></p>

Legal Character 

<p>Characters referred to using character references must match the
production for <a href="#NT-Char">Char</a>.</p>

If the character reference begins with "<code>&amp;#x</code>", the
digits and letters up to the terminating <code>;</code> provide a
hexadecimal representation of the character's code point in ISO/IEC
10646. If it begins just with "<code>&amp;#</code>", the digits up
to the terminating <code>;</code> provide a decimal representation
of the character's code point. <br />
<br />
 

<p><a id="dt-entref" name="dt-entref"></a>An <b>entity
reference</b> refers to the content of a named entity. <a
id="dt-GERef" name="dt-GERef"></a>References to parsed general
entities use ampersand (<code>&amp;</code>) and semicolon
(<code>;</code>) as delimiters. <a id="dt-PERef"
name="dt-PERef"></a> <b>Parameter-entity references</b> use
percent-sign (<code>%</code>) and semicolon (<code>;</code>) as
delimiters.</p>

<h5>Entity Reference</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-Reference" name="NT-Reference"></a>[67]   </td>
<td>Reference</td>
<td>   ::=   </td>
<td><a href="#NT-EntityRef">EntityRef</a> | <a
href="#NT-CharRef">CharRef</a></td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-EntityRef" name="NT-EntityRef"></a>[68]   </td>
<td>EntityRef</td>
<td>   ::=   </td>
<td>'&amp;' <a href="#NT-Name">Name</a> ';'</td>
<td>[ WFC: <a href="#wf-entdeclared"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td>[ VC: <a href="#vc-entdeclared"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td>[ WFC: <a href="#textent"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td>[ WFC: <a href="#norecursion"></a> ]</td>
</tr>

<tr valign="baseline">
<td><a id="NT-PEReference" name="NT-PEReference"></a>[69]   </td>
<td>PEReference</td>
<td>   ::=   </td>
<td>'%' <a href="#NT-Name">Name</a> ';'</td>
<td>[ VC: <a href="#vc-entdeclared"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td>[ WFC: <a href="#norecursion"></a> ]</td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td>[ WFC: <a href="#indtd"></a> ]</td>
</tr>
</tbody>
</table>

<a id="wf-entdeclared" name="wf-entdeclared"></a>
<p><b>Well Formedness Constraint: Entity Declared</b></p>

Entity Declared 

<p>In a document without any DTD, a document with only an internal
DTD subset which contains no parameter entity references, or a
document with "<code>standalone='yes'</code>", the <a
href="#NT-Name">Name</a> given in the entity reference must <a
href="#dt-match">match</a> that in an <a
href="#sec-entity-decl">entity declaration</a>, except that
well-formed documents need not declare any of the following
entities: . The declaration of a parameter entity must precede any
reference to it. Similarly, the declaration of a general entity
must precede any reference to it which appears in a default value
in an attribute-list declaration.</p>

<p>Note that if entities are declared in the external subset or in
external parameter entities, a non-validating processor is <a
href="#include-if-valid">not obligated to</a> read and process
their declarations; for such documents, the rule that an entity
must be declared is a well-formedness constraint only if <a
href="#sec-rmd">standalone='yes'</a>.</p>

<a id="vc-entdeclared" name="vc-entdeclared"></a>
<p><b>Validity Constraint: Entity Declared</b></p>

Entity Declared 

<p>In a document with an external subset or external parameter
entities with "<code>standalone='no'</code>", the <a
href="#NT-Name">Name</a> given in the entity reference must <a
href="#dt-match">match</a> that in an <a
href="#sec-entity-decl">entity declaration</a>. For
interoperability, valid documents should declare the entities , in
the form specified in <a href="#sec-predefined-ent">[]</a>. The
declaration of a parameter entity must precede any reference to it.
Similarly, the declaration of a general entity must precede any
reference to it which appears in a default value in an
attribute-list declaration.</p>

<a id="textent" name="textent"></a>
<p><b>Well Formedness Constraint: Parsed Entity</b></p>

Parsed Entity 

<p>An entity reference must not contain the name of an <a
href="#dt-unparsed">unparsed entity</a>. Unparsed entities may be
referred to only in <a href="#dt-attrval">attribute values</a>
declared to be of type ENTITY or ENTITIES.</p>

<a id="norecursion" name="norecursion"></a>
<p><b>Well Formedness Constraint: No Recursion</b></p>

No Recursion 

<p>A parsed entity must not contain a recursive reference to
itself, either directly or indirectly.</p>

<a id="indtd" name="indtd"></a>
<p><b>Well Formedness Constraint: In DTD</b></p>

In DTD 

<p>Parameter-entity references may only appear in the <a
href="#dt-doctype">DTD</a>.</p>

<p>Examples of character and entity references:</p>

<pre>
Type &lt;key&gt;less-than&lt;/key&gt; (3C;) to save options.
This document was prepared on &amp;docdate; and
is classified &amp;security-level;.
</pre>

<br />
<br />
 

<p>Example of a parameter-entity reference:</p>

<pre>
&lt;!-- declare the parameter entity "ISOLat2"... --&gt;
&lt;!ENTITY % ISOLat2
         SYSTEM "http://www.xml.com/iso/isolat2-xml.entities" &gt;
&lt;!-- ... now reference it. --&gt;
%ISOLat2;
</pre>

<br />
<br />
 

<h3><a id="sec-entity-decl" name="sec-entity-decl"></a>4.2 Entity
Declarations</h3>

<p><a id="dt-entdecl" name="dt-entdecl"></a> Entities are declared
thus:</p>

<h5>Entity Declaration</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-EntityDecl" name="NT-EntityDecl"></a>[70]   </td>
<td>EntityDecl</td>
<td>   ::=   </td>
<td><a href="#NT-GEDecl">GEDecl</a> | <a
href="#NT-PEDecl">PEDecl</a></td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-GEDecl" name="NT-GEDecl"></a>[71]   </td>
<td>GEDecl</td>
<td>   ::=   </td>
<td>'&lt;!ENTITY' <a href="#NT-S">S</a> <a href="#NT-Name">Name</a>
<a href="#NT-S">S</a> <a href="#NT-EntityDef">EntityDef</a> <a
href="#NT-S">S</a>? '&gt;'</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-PEDecl" name="NT-PEDecl"></a>[72]   </td>
<td>PEDecl</td>
<td>   ::=   </td>
<td>'&lt;!ENTITY' <a href="#NT-S">S</a> '%' <a href="#NT-S">S</a>
<a href="#NT-Name">Name</a> <a href="#NT-S">S</a> <a
href="#NT-PEDef">PEDef</a> <a href="#NT-S">S</a>? '&gt;'</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-EntityDef" name="NT-EntityDef"></a>[73]   </td>
<td>EntityDef</td>
<td>   ::=   </td>
<td><a href="#NT-EntityValue">EntityValue</a> | (<a
href="#NT-ExternalID">ExternalID</a> <a
href="#NT-NDataDecl">NDataDecl</a>?)</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-PEDef" name="NT-PEDef"></a>[74]   </td>
<td>PEDef</td>
<td>   ::=   </td>
<td><a href="#NT-EntityValue">EntityValue</a> | <a
href="#NT-ExternalID">ExternalID</a></td>
<td></td>
</tr>
</tbody>
</table>

The <a href="#NT-Name">Name</a> identifies the entity in an <a
href="#dt-entref">entity reference</a> or, in the case of an
unparsed entity, in the value of an ENTITY or ENTITIES attribute.
If the same entity is declared more than once, the first
declaration encountered is binding; at user option, an XML
processor may issue a warning if entities are declared multiple
times. <br />
<br />
 

<h4><a id="sec-internal-ent" name="sec-internal-ent"></a>4.2.1
Internal Entities</h4>

<p><a id="dt-internent" name="dt-internent"></a>If the entity
definition is an <a href="#NT-EntityValue">EntityValue</a>, the
defined entity is called an <b>internal entity</b>. There is no
separate physical storage object, and the content of the entity is
given in the declaration. Note that some processing of entity and
character references in the <a href="#dt-litentval">literal entity
value</a> may be required to produce the correct <a
href="#dt-repltext">replacement text</a>: see <a
href="#intern-replacement">[]</a>.</p>

<p>An internal entity is a <a href="#dt-parsedent">parsed
entity</a>.</p>

<p>Example of an internal entity declaration:</p>

<pre>
&lt;!ENTITY Pub-Status "This is a pre-release of the
 specification."&gt;
</pre>

<br />
<br />
 

<h4><a id="sec-external-ent" name="sec-external-ent"></a>4.2.2
External Entities</h4>

<p><a id="dt-extent" name="dt-extent"></a>If the entity is not
internal, it is an <b>external entity</b>, declared as follows:</p>

<h5>External Entity Declaration</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-ExternalID" name="NT-ExternalID"></a>[75]   </td>
<td>ExternalID</td>
<td>   ::=   </td>
<td>'SYSTEM' <a href="#NT-S">S</a> <a
href="#NT-SystemLiteral">SystemLiteral</a></td>
<td></td>
</tr>

<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td>| 'PUBLIC' <a href="#NT-S">S</a> <a
href="#NT-PubidLiteral">PubidLiteral</a> <a href="#NT-S">S</a> <a
href="#NT-SystemLiteral">SystemLiteral</a> </td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-NDataDecl" name="NT-NDataDecl"></a>[76]   </td>
<td>NDataDecl</td>
<td>   ::=   </td>
<td><a href="#NT-S">S</a> 'NDATA' <a href="#NT-S">S</a> <a
href="#NT-Name">Name</a></td>
<td>[ VC: <a href="#not-declared"></a> ]</td>
</tr>
</tbody>
</table>

If the <a href="#NT-NDataDecl">NDataDecl</a> is present, this is a
general <a href="#dt-unparsed">unparsed entity</a>; otherwise it is
a parsed entity.<br />
<br />
 <a id="not-declared" name="not-declared"></a>
<p><b>Validity Constraint: Notation Declared</b></p>

Notation Declared 

<p>The <a href="#NT-Name">Name</a> must match the declared name of
a <a href="#dt-notation">notation</a>.</p>

<p><a id="dt-sysid" name="dt-sysid"></a>The <a
href="#NT-SystemLiteral">SystemLiteral</a> is called the entity's
<b>system identifier</b>. It is a URI, which may be used to
retrieve the entity. Note that the hash mark (<code>#</code>) and
fragment identifier frequently used with URIs are not, formally,
part of the URI itself; an XML processor may signal an error if a
fragment identifier is given as part of a system identifier. Unless
otherwise provided by information outside the scope of this
specification (e.g. a special XML element type defined by a
particular DTD, or a processing instruction defined by a particular
application specification), relative URIs are relative to the
location of the resource within which the entity declaration
occurs. A URI might thus be relative to the <a
href="#dt-docent">document entity</a>, to the entity containing the
<a href="#dt-doctype">external DTD subset</a>, or to some other <a
href="#dt-extent">external parameter entity</a>.</p>

<p>An XML processor should handle a non-ASCII character in a URI by
representing the character in UTF-8 as one or more bytes, and then
escaping these bytes with the URI escaping mechanism (i.e., by
converting each byte to %HH, where HH is the hexadecimal notation
of the byte value).</p>

<p><a id="dt-pubid" name="dt-pubid"></a> In addition to a system
identifier, an external identifier may include a <b>public
identifier</b>. An XML processor attempting to retrieve the
entity's content may use the public identifier to try to generate
an alternative URI. If the processor is unable to do so, it must
use the URI specified in the system literal. Before a match is
attempted, all strings of white space in the public identifier must
be normalized to single space characters (#x20), and leading and
trailing white space must be removed.</p>

<p>Examples of external entity declarations:</p>

<pre>
&lt;!ENTITY open-hatch
         SYSTEM "http://www.textuality.com/boilerplate/OpenHatch.xml"&gt;
&lt;!ENTITY open-hatch
         PUBLIC "-//Textuality//TEXT Standard open-hatch boilerplate//EN"
         "http://www.textuality.com/boilerplate/OpenHatch.xml"&gt;
&lt;!ENTITY hatch-pic
         SYSTEM "../grafix/OpenHatch.gif"
         NDATA gif &gt;
</pre>

<br />
<br />
 

<h3><a id="TextEntities" name="TextEntities"></a>4.3 Parsed
Entities</h3>

<h4><a id="sec-TextDecl" name="sec-TextDecl"></a>4.3.1 The Text
Declaration</h4>

<p>External parsed entities may each begin with a <b>text
declaration</b>.</p>

<h5>Text Declaration</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-TextDecl" name="NT-TextDecl"></a>[77]   </td>
<td>TextDecl</td>
<td>   ::=   </td>
<td><a href="#NT-VersionInfo">VersionInfo</a>? <a
href="#NT-EncodingDecl">EncodingDecl</a> <a
href="#NT-S">S</a>?</td>
<td></td>
</tr>
</tbody>
</table>

<br />
<br />
 

<p>The text declaration must be provided literally, not by
reference to a parsed entity. No text declaration may appear at any
position other than the beginning of an external parsed entity.</p>

<h4><a id="wf-entities" name="wf-entities"></a>4.3.2 Well-Formed
Parsed Entities</h4>

<p>The document entity is well-formed if it matches the production
labeled <a href="#NT-document">document</a>. An external general
parsed entity is well-formed if it matches the production labeled
<a href="#NT-extParsedEnt">extParsedEnt</a>. An external parameter
entity is well-formed if it matches the production labeled <a
href="#NT-extPE">extPE</a>.</p>

<h5>Well-Formed External Parsed Entity</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-extParsedEnt" name="NT-extParsedEnt"></a>[78]   </td>
<td>extParsedEnt</td>
<td>   ::=   </td>
<td><a href="#NT-TextDecl">TextDecl</a>? <a
href="#NT-content">content</a></td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-extPE" name="NT-extPE"></a>[79]   </td>
<td>extPE</td>
<td>   ::=   </td>
<td><a href="#NT-TextDecl">TextDecl</a>? <a
href="#NT-extSubsetDecl">extSubsetDecl</a></td>
<td></td>
</tr>
</tbody>
</table>

An internal general parsed entity is well-formed if its replacement
text matches the production labeled <a
href="#NT-content">content</a>. All internal parameter entities are
well-formed by definition. <br />
<br />
 

<p>A consequence of well-formedness in entities is that the logical
and physical structures in an XML document are properly nested; no
<a href="#dt-stag">start-tag</a>, <a href="#dt-etag">end-tag</a>,
<a href="#dt-empty">empty-element tag</a>, <a
href="#dt-element">element</a>, <a href="#dt-comment">comment</a>,
<a href="#dt-pi">processing instruction</a>, <a
href="#dt-charref">character reference</a>, or <a
href="#dt-entref">entity reference</a> can begin in one entity and
end in another.</p>

<h4><a id="charencoding" name="charencoding"></a>4.3.3 Character
Encoding in Entities</h4>

<p>Each external parsed entity in an XML document may use a
different encoding for its characters. All XML processors must be
able to read entities in either UTF-8 or UTF-16.</p>

<p>Entities encoded in UTF-16 must begin with the Byte Order Mark
described by ISO/IEC 10646 Annex E and Unicode Appendix B (the ZERO
WIDTH NO-BREAK SPACE character, #xFEFF). This is an encoding
signature, not part of either the markup or the character data of
the XML document. XML processors must be able to use this character
to differentiate between UTF-8 and UTF-16 encoded documents.</p>

<p>Although an XML processor is required to read only entities in
the UTF-8 and UTF-16 encodings, it is recognized that other
encodings are used around the world, and it may be desired for XML
processors to read entities that use them. Parsed entities which
are stored in an encoding other than UTF-8 or UTF-16 must begin
with a <a href="#TextDecl">text declaration</a> containing an
encoding declaration:</p>

<h5>Encoding Declaration</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-EncodingDecl" name="NT-EncodingDecl"></a>[80]   </td>
<td>EncodingDecl</td>
<td>   ::=   </td>
<td><a href="#NT-S">S</a> 'encoding' <a href="#NT-Eq">Eq</a> ('"'
<a href="#NT-EncName">EncName</a> '"' | "'" <a
href="#NT-EncName">EncName</a> "'" )</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-EncName" name="NT-EncName"></a>[81]   </td>
<td>EncName</td>
<td>   ::=   </td>
<td>[A-Za-z] ([A-Za-z0-9._] | '-')*</td>
<td>/*Encoding name contains only Latin characters*/</td>
</tr>
</tbody>
</table>

In the <a href="#dt-docent">document entity</a>, the encoding
declaration is part of the <a href="#dt-xmldecl">XML
declaration</a>. The <a href="#NT-EncName">EncName</a> is the name
of the encoding used. <br />
<br />
 

<p>In an encoding declaration, the values "<code>UTF-8</code>",
"<code>UTF-16</code>", "<code>ISO-10646-UCS-2</code>", and
"<code>ISO-10646-UCS-4</code>" should be used for the various
encodings and transformations of Unicode / ISO/IEC 10646, the
values "<code>ISO-8859-1</code>", "<code>ISO-8859-2</code>", ...
"<code>ISO-8859-9</code>" should be used for the parts of ISO 8859,
and the values "<code>ISO-2022-JP</code>",
"<code>Shift_JIS</code>", and "<code>EUC-JP</code>" should be used
for the various encoded forms of JIS X-0208-1997. XML processors
may recognize other encodings; it is recommended that character
encodings registered (as <i>charset</i>s) with the Internet
Assigned Numbers Authority <a href="#IANA">[]</a>, other than those
just listed, should be referred to using their registered names.
Note that these registered names are defined to be
case-insensitive, so processors wishing to match against them
should do so in a case-insensitive way.</p>

<p>In the absence of information provided by an external transport
protocol (e.g. HTTP or MIME), it is an <a
href="#dt-error">error</a> for an entity including an encoding
declaration to be presented to the XML processor in an encoding
other than that named in the declaration, for an encoding
declaration to occur other than at the beginning of an external
entity, or for an entity which begins with neither a Byte Order
Mark nor an encoding declaration to use an encoding other than
UTF-8. Note that since ASCII is a subset of UTF-8, ordinary ASCII
entities do not strictly need an encoding declaration.</p>

<p>It is a <a href="#dt-fatal">fatal error</a> when an XML
processor encounters an entity with an encoding that it is unable
to process.</p>

<p>Examples of encoding declarations:</p>

<pre>
&lt;?xml encoding='UTF-8'?&gt;
&lt;?xml encoding='EUC-JP'?&gt;
</pre>

<br />
<br />
 

<h3><a id="entproc" name="entproc"></a>4.4 XML Processor Treatment
of Entities and References</h3>

<p>The table below summarizes the contexts in which character
references, entity references, and invocations of unparsed entities
might appear and the required behavior of an <a
href="#dt-xml-proc">XML processor</a> in each case. The labels in
the leftmost column describe the recognition context:</p>

<dl>
<dt><b>Reference in Content</b></dt>

<dd>
<p>as a reference anywhere after the <a
href="#dt-stag">start-tag</a> and before the <a
href="#dt-etag">end-tag</a> of an element; corresponds to the
nonterminal <a href="#NT-content">content</a>.</p>
</dd>

<dt><b>Reference in Attribute Value</b></dt>

<dd>
<p>as a reference within either the value of an attribute in a <a
href="#dt-stag">start-tag</a>, or a default value in an <a
href="#dt-attdecl">attribute declaration</a>; corresponds to the
nonterminal <a href="#NT-AttValue">AttValue</a>.</p>
</dd>

<dt><b>Occurs as Attribute Value</b></dt>

<dd>
<p>as a <a href="#NT-Name">Name</a>, not a reference, appearing
either as the value of an attribute which has been declared as type
ENTITY, or as one of the space-separated tokens in the value of an
attribute which has been declared as type ENTITIES.</p>
</dd>

<dt><b>Reference in Entity Value</b></dt>

<dd>
<p>as a reference within a parameter or internal entity's <a
href="#dt-litentval">literal entity value</a> in the entity's
declaration; corresponds to the nonterminal <a
href="#NT-EntityValue">EntityValue</a>.</p>
</dd>

<dt><b>Reference in DTD</b></dt>

<dd>
<p>as a reference within either the internal or external subsets of
the <a href="#dt-doctype">DTD</a>, but outside of an <a
href="#NT-EntityValue">EntityValue</a> or <a
href="#NT-AttValue">AttValue</a>.</p>
</dd>
</dl>

<br />
<br />
 

<table border="1" cellpadding="7" align="center">
<tbody>
<tr align="" valign="">
<td bgcolor="" rowspan="2" colspan="1" align="" valign=""></td>
<td bgcolor="" rowspan="" colspan="4" align="center"
valign="bottom">Entity Type</td>
<td bgcolor="" rowspan="2" colspan="" align="center" valign="">
Character</td>
</tr>

<tr align="center" valign="bottom">
<td bgcolor="" rowspan="" colspan="" align="" valign="">
Parameter</td>
<td bgcolor="" rowspan="" colspan="" align="" valign="">Internal
General</td>
<td bgcolor="" rowspan="" colspan="" align="" valign="">External
Parsed General</td>
<td bgcolor="" rowspan="" colspan="" align="" valign="">
Unparsed</td>
</tr>

<tr align="center" valign="middle">
<td bgcolor="" rowspan="" colspan="" align="right" valign="">
Reference in Content</td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#not-recognized">Not recognized</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#included">Included</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#include-if-valid">Included if validating</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#forbidden">Forbidden</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#included">Included</a></td>
</tr>

<tr align="center" valign="middle">
<td bgcolor="" rowspan="" colspan="" align="right" valign="">
Reference in Attribute Value</td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#not-recognized">Not recognized</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#inliteral">Included in literal</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#forbidden">Forbidden</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#forbidden">Forbidden</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#included">Included</a></td>
</tr>

<tr align="center" valign="middle">
<td bgcolor="" rowspan="" colspan="" align="right" valign="">Occurs
as Attribute Value</td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#not-recognized">Not recognized</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#not-recognized">Forbidden</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#not-recognized">Forbidden</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#notify">Notify</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#not recognized">Not recognized</a></td>
</tr>

<tr align="center" valign="middle">
<td bgcolor="" rowspan="" colspan="" align="right" valign="">
Reference in EntityValue</td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#inliteral">Included in literal</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#bypass">Bypassed</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#bypass">Bypassed</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#forbidden">Forbidden</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#included">Included</a></td>
</tr>

<tr align="center" valign="middle">
<td bgcolor="" rowspan="" colspan="" align="right" valign="">
Reference in DTD</td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#as-PE">Included as PE</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#forbidden">Forbidden</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#forbidden">Forbidden</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#forbidden">Forbidden</a></td>
<td bgcolor="" rowspan="" colspan="" align="" valign=""><a
href="#forbidden">Forbidden</a></td>
</tr>
</tbody>
</table>

<h4><a id="not-recognized" name="not-recognized"></a>4.4.1 Not
Recognized</h4>

<p>Outside the DTD, the <code>%</code> character has no special
significance; thus, what would be parameter entity references in
the DTD are not recognized as markup in <a
href="#NT-content">content</a>. Similarly, the names of unparsed
entities are not recognized except when they appear in the value of
an appropriately declared attribute.</p>

<h4><a id="included" name="included"></a>4.4.2 Included</h4>

<p><a id="dt-include" name="dt-include"></a>An entity is
<b>included</b> when its <a href="#dt-repltext">replacement
text</a> is retrieved and processed, in place of the reference
itself, as though it were part of the document at the location the
reference was recognized. The replacement text may contain both <a
href="#dt-chardata">character data</a> and (except for parameter
entities) <a href="#dt-markup">markup</a>, which must be recognized
in the usual way, except that the replacement text of entities used
to escape markup delimiters (the entities ) is always treated as
data. (The string "<code>AT&amp;amp;T;</code>" expands to
"<code>AT&amp;T;</code>" and the remaining ampersand is not
recognized as an entity-reference delimiter.) A character reference
is <b>included</b> when the indicated character is processed in
place of the reference itself.</p>

<h4><a id="include-if-valid" name="include-if-valid"></a>4.4.3
Included If Validating</h4>

<p>When an XML processor recognizes a reference to a parsed entity,
in order to <a href="#dt-valid">validate</a> the document, the
processor must <a href="#dt-include">include</a> its replacement
text. If the entity is external, and the processor is not
attempting to validate the XML document, the processor <a
href="#dt-may">may</a>, but need not, include the entity's
replacement text. If a non-validating parser does not include the
replacement text, it must inform the application that it
recognized, but did not read, the entity.</p>

<p>This rule is based on the recognition that the automatic
inclusion provided by the SGML and XML entity mechanism, primarily
designed to support modularity in authoring, is not necessarily
appropriate for other applications, in particular document
browsing. Browsers, for example, when encountering an external
parsed entity reference, might choose to provide a visual
indication of the entity's presence and retrieve it for display
only on demand.</p>

<h4><a id="forbidden" name="forbidden"></a>4.4.4 Forbidden</h4>

<p>The following are forbidden, and constitute <a
href="#dt-fatal">fatal</a> errors:</p>

<ul>
<li>
<p>the appearance of a reference to an <a
href="#dt-unparsed">unparsed entity</a>.</p>
</li>

<li>
<p>the appearance of any character or general-entity reference in
the DTD except within an <a href="#NT-EntityValue">EntityValue</a>
or <a href="#NT-AttValue">AttValue</a>.</p>
</li>

<li>
<p>a reference to an external entity in an attribute value.</p>
</li>
</ul>

<br />
<br />
 

<h4><a id="inliteral" name="inliteral"></a>4.4.5 Included in
Literal</h4>

<p>When an <a href="#dt-entref">entity reference</a> appears in an
attribute value, or a parameter entity reference appears in a
literal entity value, its <a href="#dt-repltext">replacement
text</a> is processed in place of the reference itself as though it
were part of the document at the location the reference was
recognized, except that a single or double quote character in the
replacement text is always treated as a normal data character and
will not terminate the literal. For example, this is
well-formed:</p>

<pre>
&lt;!ENTITY % YN '"Yes"' &gt;
&lt;!ENTITY WhatHeSaid "He said &amp;YN;" &gt;
</pre>

while this is not: 

<pre>
&lt;!ENTITY EndAttr "27'" &gt;
&lt;element attribute='a-&amp;EndAttr;&gt;
</pre>

<br />
<br />
 

<h4><a id="notify" name="notify"></a>4.4.6 Notify</h4>

<p>When the name of an <a href="#dt-unparsed">unparsed entity</a>
appears as a token in the value of an attribute of declared type
ENTITY or ENTITIES, a validating processor must inform the
application of the <a href="#dt-sysid">system</a> and <a
href="#dt-pubid">public</a> (if any) identifiers for both the
entity and its associated <a href="#dt-notation">notation</a>.</p>

<h4><a id="bypass" name="bypass"></a>4.4.7 Bypassed</h4>

<p>When a general entity reference appears in the <a
href="#NT-EntityValue">EntityValue</a> in an entity declaration, it
is bypassed and left as is.</p>

<h4><a id="as-PE" name="as-PE"></a>4.4.8 Included as PE</h4>

<p>Just as with external parsed entities, parameter entities need
only be <a href="#include-if-valid">included if validating</a>.
When a parameter-entity reference is recognized in the DTD and
included, its <a href="#dt-repltext">replacement text</a> is
enlarged by the attachment of one leading and one following space
(#x20) character; the intent is to constrain the replacement text
of parameter entities to contain an integral number of grammatical
tokens in the DTD.</p>

<h3><a id="intern-replacement" name="intern-replacement"></a>4.5
Construction of Internal Entity Replacement Text</h3>

<p>In discussing the treatment of internal entities, it is useful
to distinguish two forms of the entity's value. <a
id="dt-litentval" name="dt-litentval"></a>The <b>literal entity
value</b> is the quoted string actually present in the entity
declaration, corresponding to the non-terminal <a
href="#NT-EntityValue">EntityValue</a>. <a id="dt-repltext"
name="dt-repltext"></a>The <b>replacement text</b> is the content
of the entity, after replacement of character references and
parameter-entity references.</p>

<p>The literal entity value as given in an internal entity
declaration (<a href="#NT-EntityValue">EntityValue</a>) may contain
character, parameter-entity, and general-entity references. Such
references must be contained entirely within the literal entity
value. The actual replacement text that is <a
href="#dt-include">included</a> as described above must contain the
<i>replacement text</i> of any parameter entities referred to, and
must contain the character referred to, in place of any character
references in the literal entity value; however, general-entity
references must be left as-is, unexpanded. For example, given the
following declarations:</p>

<pre>
&lt;!ENTITY % pub    "&amp;#xc9;ditions Gallimard" &gt;
&lt;!ENTITY   rights "All rights reserved" &gt;
&lt;!ENTITY   book   "La Peste: Albert Camus, 
&amp;#xA9; 1947 %pub;. &amp;rights;" &gt;
</pre>

then the replacement text for the entity "<code>book</code>" is: 

<pre>
La Peste: Albert Camus, 
© 1947 Éditions Gallimard. &amp;rights;
</pre>

The general-entity reference "<code>&amp;rights;</code>" would be
expanded should the reference "<code>&amp;book;</code>" appear in
the document's content or an attribute value.<br />
<br />
 

<p>These simple rules may have complex interactions; for a detailed
discussion of a difficult example, see <a
href="#sec-entexpand">[]</a>.</p>

<h3><a id="sec-predefined-ent" name="sec-predefined-ent"></a>4.6
Predefined Entities</h3>

<p><a id="dt-escape" name="dt-escape"></a>Entity and character
references can both be used to <b>escape</b> the left angle
bracket, ampersand, and other delimiters. A set of general entities
() is specified for this purpose. Numeric character references may
also be used; they are expanded immediately when recognized and
must be treated as character data, so the numeric character
references "<code>&amp;#60;</code>" and "<code>&amp;#38;</code>"
may be used to escape <code>&lt;</code> and <code>&amp;</code> when
they occur in character data.</p>

<p>All XML processors must recognize these entities whether they
are declared or not. <a href="#dt-interop">For
interoperability</a>, valid XML documents should declare these
entities, like any others, before using them. If the entities in
question are declared, they must be declared as internal entities
whose replacement text is the single character being escaped or a
character reference to that character, as shown below.</p>

<pre>
&lt;!ENTITY lt     "&amp;#38;#60;"&gt; 
&lt;!ENTITY gt     "&amp;#62;"&gt; 
&lt;!ENTITY amp    "&amp;#38;#38;"&gt; 
&lt;!ENTITY apos   "&amp;#39;"&gt; 
&lt;!ENTITY quot   "&amp;#34;"&gt; 
</pre>

Note that the <code>&lt;</code> and <code>&amp;</code> characters
in the declarations of "<code>lt</code>" and "<code>amp</code>" are
doubly escaped to meet the requirement that entity replacement be
well-formed. <br />
<br />
 

<h3><a id="Notations" name="Notations"></a>4.7 Notation
Declarations</h3>

<p><a id="dt-notation" name="dt-notation"></a><b>Notations</b>
identify by name the format of <a href="#dt-extent">unparsed
entities</a>, the format of elements which bear a notation
attribute, or the application to which a <a
href="#dt-pi">processing instruction</a> is addressed.</p>

<p><a id="dt-notdecl" name="dt-notdecl"></a> <b>Notation
declarations</b> provide a name for the notation, for use in entity
and attribute-list declarations and in attribute specifications,
and an external identifier for the notation which may allow an XML
processor or its client application to locate a helper application
capable of processing data in the given notation.</p>

<h5>Notation Declarations</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-NotationDecl" name="NT-NotationDecl"></a>[82]   </td>
<td>NotationDecl</td>
<td>   ::=   </td>
<td>'&lt;!NOTATION' <a href="#NT-S">S</a> <a
href="#NT-Name">Name</a> <a href="#NT-S">S</a> (<a
href="#NT-ExternalID">ExternalID</a> | <a
href="#NT-PublicID">PublicID</a>) <a href="#NT-S">S</a>?
'&gt;'</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-PublicID" name="NT-PublicID"></a>[83]   </td>
<td>PublicID</td>
<td>   ::=   </td>
<td>'PUBLIC' <a href="#NT-S">S</a> <a
href="#NT-PubidLiteral">PubidLiteral</a> </td>
<td></td>
</tr>
</tbody>
</table>

<br />
<br />
 

<p>XML processors must provide applications with the name and
external identifier(s) of any notation declared and referred to in
an attribute value, attribute definition, or entity declaration.
They may additionally resolve the external identifier into the <a
href="#dt-sysid">system identifier</a>, file name, or other
information needed to allow the application to call a processor for
data in the notation described. (It is not an error, however, for
XML documents to declare and refer to notations for which
notation-specific applications are not available on the system
where the XML processor or application is running.)</p>

<h3><a id="sec-doc-entity" name="sec-doc-entity"></a>4.8 Document
Entity</h3>

<p><a id="dt-docent" name="dt-docent"></a>The <b>document
entity</b> serves as the root of the entity tree and a
starting-point for an <a href="#dt-xml-proc">XML processor</a>.
This specification does not specify how the document entity is to
be located by an XML processor; unlike other entities, the document
entity has no name and might well appear on a processor input
stream without any identification at all.</p>

<h2><a id="sec-conformance" name="sec-conformance"></a>5
Conformance</h2>

<h3><a id="proc-types" name="proc-types"></a>5.1 Validating and
Non-Validating Processors</h3>

<p>Conforming <a href="#dt-xml-proc">XML processors</a> fall into
two classes: validating and non-validating.</p>

<p>Validating and non-validating processors alike must report
violations of this specification's well-formedness constraints in
the content of the <a href="#dt-docent">document entity</a> and any
other <a href="#dt-parsedent">parsed entities</a> that they
read.</p>

<p><a id="dt-validating" name="dt-validating"></a> <b>Validating
processors</b> must report violations of the constraints expressed
by the declarations in the <a href="#dt-doctype">DTD</a>, and
failures to fulfill the validity constraints given in this
specification. To accomplish this, validating XML processors must
read and process the entire DTD and all external parsed entities
referenced in the document.</p>

<p>Non-validating processors are required to check only the <a
href="#dt-docent">document entity</a>, including the entire
internal DTD subset, for well-formedness. <a id="dt-use-mdecl"
name="dt-use-mdecl"></a> While they are not required to check the
document for validity, they are required to <b>process</b> all the
declarations they read in the internal DTD subset and in any
parameter entity that they read, up to the first reference to a
parameter entity that they do <i>not</i> read; that is to say, they
must use the information in those declarations to <a
href="#AVNormalize">normalize</a> attribute values, <a
href="#included">include</a> the replacement text of internal
entities, and supply <a href="#sec-attr-defaults">default attribute
values</a>. They must not <a href="#dt-use-mdecl">process</a> <a
href="#dt-entdecl">entity declarations</a> or <a
href="#dt-attdecl">attribute-list declarations</a> encountered
after a reference to a parameter entity that is not read, since the
entity may have contained overriding declarations.</p>

<h3><a id="safe-behavior" name="safe-behavior"></a>5.2 Using XML
Processors</h3>

<p>The behavior of a validating XML processor is highly
predictable; it must read every piece of a document and report all
well-formedness and validity violations. Less is required of a
non-validating processor; it need not read any part of the document
other than the document entity. This has two effects that may be
important to users of XML processors:</p>

<ul>
<li>
<p>Certain well-formedness errors, specifically those that require
reading external entities, may not be detected by a non-validating
processor. Examples include the constraints entitled <a
href="#wf-entdeclared">Entity Declared</a>, <a
href="#wf-textent">Parsed Entity</a>, and <a
href="#wf-norecursion">No Recursion</a>, as well as some of the
cases described as <a href="#forbidden">forbidden</a> in <a
href="#entproc">[]</a>.</p>
</li>

<li>
<p>The information passed from the processor to the application may
vary, depending on whether the processor reads parameter and
external entities. For example, a non-validating processor may not
<a href="#AVNormalize">normalize</a> attribute values, <a
href="#included">include</a> the replacement text of internal
entities, or supply <a href="#sec-attr-defaults">default attribute
values</a>, where doing so depends on having read declarations in
external or parameter entities.</p>
</li>
</ul>

<br />
<br />
 

<p>For maximum reliability in interoperating between different XML
processors, applications which use non-validating processors should
not rely on any behaviors not required of such processors.
Applications which require facilities such as the use of default
attributes or internal entities which are declared in external
entities should use validating XML processors.</p>

<h2><a id="sec-notation" name="sec-notation"></a>6 Notation</h2>

<p>The formal grammar of XML is given in this specification using a
simple Extended Backus-Naur Form (EBNF) notation. Each rule in the
grammar defines one symbol, in the form</p>

<pre>
symbol ::= expression
</pre>

<br />
<br />
 

<p>Symbols are written with an initial capital letter if they are
defined by a regular expression, or with an initial lower case
letter otherwise. Literal strings are quoted.</p>

<p>Within the expression on the right-hand side of a rule, the
following expressions are used to match strings of one or more
characters:</p>

<dl>
<dt><b><code>#xN</code></b></dt>

<dd>
<p>where <code>N</code> is a hexadecimal integer, the expression
matches the character in ISO/IEC 10646 whose canonical (UCS-4) code
value, when interpreted as an unsigned binary number, has the value
indicated. The number of leading zeros in the <code>#xN</code> form
is insignificant; the number of leading zeros in the corresponding
code value is governed by the character encoding in use and is not
significant for XML.</p>
</dd>

<dt><b><code>[a-zA-Z]</code>, <code>[#xN-#xN]</code></b></dt>

<dd>
<p>matches any <a href="#dt-character">character</a> with a value
in the range(s) indicated (inclusive).</p>
</dd>

<dt><b><code>[^a-z]</code>, <code>[^#xN-#xN]</code></b></dt>

<dd>
<p>matches any <a href="#dt-character">character</a> with a value
<i>outside</i> the range indicated.</p>
</dd>

<dt><b><code>[^abc]</code>, <code>[^#xN#xN#xN]</code></b></dt>

<dd>
<p>matches any <a href="#dt-character">character</a> with a value
not among the characters given.</p>
</dd>

<dt><b><code>"string"</code></b></dt>

<dd>
<p>matches a literal string <a href="#dt-match">matching</a> that
given inside the double quotes.</p>
</dd>

<dt><b><code>'string'</code></b></dt>

<dd>
<p>matches a literal string <a href="#dt-match">matching</a> that
given inside the single quotes.</p>
</dd>
</dl>

These symbols may be combined to match more complex patterns as
follows, where <code>A</code> and <code>B</code> represent simple
expressions: 

<dl>
<dt><b>(<code>expression</code>)</b></dt>

<dd>
<p><code>expression</code> is treated as a unit and may be combined
as described in this list.</p>
</dd>

<dt><b><code>A?</code></b></dt>

<dd>
<p>matches <code>A</code> or nothing; optional <code>A</code>.</p>
</dd>

<dt><b><code>A B</code></b></dt>

<dd>
<p>matches <code>A</code> followed by <code>B</code>.</p>
</dd>

<dt><b><code>A | B</code></b></dt>

<dd>
<p>matches <code>A</code> or <code>B</code> but not both.</p>
</dd>

<dt><b><code>A - B</code></b></dt>

<dd>
<p>matches any string that matches <code>A</code> but does not
match <code>B</code>.</p>
</dd>

<dt><b><code>A+</code></b></dt>

<dd>
<p>matches one or more occurrences of <code>A</code>.</p>
</dd>

<dt><b><code>A*</code></b></dt>

<dd>
<p>matches zero or more occurrences of <code>A</code>.</p>
</dd>
</dl>

Other notations used in the productions are: 

<dl>
<dt><b><code>/* ... */</code></b></dt>

<dd>
<p>comment.</p>
</dd>

<dt><b><code>[ wfc: ... ]</code></b></dt>

<dd>
<p>well-formedness constraint; this identifies by name a constraint
on <a href="#dt-wellformed">well-formed</a> documents associated
with a production.</p>
</dd>

<dt><b><code>[ vc: ... ]</code></b></dt>

<dd>
<p>validity constraint; this identifies by name a constraint on <a
href="#dt-valid">valid</a> documents associated with a
production.</p>
</dd>
</dl>

<br />
<br />
 

<hr title="Separator from footer" />
<h2><a id="sec-bibliography" name="sec-bibliography"></a>A
References</h2>

<h3><a id="sec-existing-stds" name="sec-existing-stds"></a>A.1
Normative References</h3>

<dl>
<dt><a id="IANA" name="IANA">IANA</a></dt>

<dd>(Internet Assigned Numbers Authority) <i>Official Names for
Character Sets</i>, ed. Keld Simonsen et al. See <a
href="ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets">ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets</a>.</dd>

<dt><a id="RFC1766" name="RFC1766">IETF RFC 1766</a></dt>

<dd>IETF (Internet Engineering Task Force). <i>RFC 1766: Tags for
the Identification of Languages</i>, ed. H. Alvestrand. 1995.</dd>

<dt><a id="ISO639" name="ISO639">ISO 639</a></dt>

<dd>(International Organization for Standardization). <i>ISO
639:1988 (E). Code for the representation of names of
languages.</i> [Geneva]: International Organization for
Standardization, 1988.</dd>

<dt><a id="ISO3166" name="ISO3166">ISO 3166</a></dt>

<dd>(International Organization for Standardization). <i>ISO
3166-1:1997 (E). Codes for the representation of names of countries
and their subdivisions Part 1: Country codes</i> [Geneva]:
International Organization for Standardization, 1997.</dd>

<dt><a id="ISO10646" name="ISO10646">ISO/IEC 10646</a></dt>

<dd>ISO (International Organization for Standardization).
<i>ISO/IEC 10646-1993 (E). Information technology Universal
Multiple-Octet Coded Character Set (UCS) Part 1: Architecture and
Basic Multilingual Plane.</i> [Geneva]: International Organization
for Standardization, 1993 (plus amendments AM 1 through AM 7).</dd>

<dt><a id="Unicode" name="Unicode">Unicode</a></dt>

<dd>The Unicode Consortium. <i>The Unicode Standard, Version
2.0.</i> Reading, Mass.: Addison-Wesley Developers Press,
1996.</dd>
</dl>

<h3><a id="section-Other-References"
name="section-Other-References"></a>A.2 Other References</h3>

<dl>
<dt><a id="Aho" name="Aho">Aho/Ullman</a></dt>

<dd>Aho, Alfred V., Ravi Sethi, and Jeffrey D. Ullman.
<i>Compilers: Principles, Techniques, and Tools</i>. Reading:
Addison-Wesley, 1986, rpt. corr. 1988.</dd>

<dt><a id="Berners-Lee" name="Berners-Lee">Berners-Lee et
al.</a></dt>

<dd>Berners-Lee, T., R. Fielding, and L. Masinter. <i>Uniform
Resource Identifiers (URI): Generic Syntax and Semantics</i>. 1997.
(Work in progress; see updates to RFC1738.)</dd>

<dt><a id="ABK" name="ABK">Brüggemann-Klein</a></dt>

<dd>Brüggemann-Klein, Anne. <i>Regular Expressions into Finite
Automata</i>. Extended abstract in I. Simon, Hrsg., LATIN 1992, S.
97-98. Springer-Verlag, Berlin 1992. Full Version in Theoretical
Computer Science 120: 197-213, 1993.</dd>

<dt><a id="ABKDW" name="ABKDW">Brüggemann-Klein and Wood</a></dt>

<dd>Brüggemann-Klein, Anne, and Derick Wood. <i>Deterministic
Regular Languages</i>. Universität Freiburg, Institut für
Informatik, Bericht 38, Oktober 1991.</dd>

<dt><a id="Clark" name="Clark">Clark</a></dt>

<dd>James Clark. Comparison of SGML and XML. See <a
href="http://www.w3.org/TR/NOTE-sgml-xml-971215">http://www.w3.org/TR/NOTE-sgml-xml-971215</a>.</dd>

<dt><a id="RFC1738" name="RFC1738">IETF RFC1738</a></dt>

<dd>IETF (Internet Engineering Task Force). <i>RFC 1738: Uniform
Resource Locators (URL)</i>, ed. T. Berners-Lee, L. Masinter, M.
McCahill. 1994.</dd>

<dt><a id="RFC1808" name="RFC1808">IETF RFC1808</a></dt>

<dd>IETF (Internet Engineering Task Force). <i>RFC 1808: Relative
Uniform Resource Locators</i>, ed. R. Fielding. 1995.</dd>

<dt><a id="RFC2141" name="RFC2141">IETF RFC2141</a></dt>

<dd>IETF (Internet Engineering Task Force). <i>RFC 2141: URN
Syntax</i>, ed. R. Moats. 1997.</dd>

<dt><a id="ISO8879" name="ISO8879">ISO 8879</a></dt>

<dd>ISO (International Organization for Standardization). <i>ISO
8879:1986(E). Information processing Text and Office Systems
Standard Generalized Markup Language (SGML).</i> First edition
1986-10-15. [Geneva]: International Organization for
Standardization, 1986.</dd>

<dt><a id="ISO10744" name="ISO10744">ISO/IEC 10744</a></dt>

<dd>ISO (International Organization for Standardization).
<i>ISO/IEC 10744-1992 (E). Information technology
Hypermedia/Time-based Structuring Language (HyTime).</i> [Geneva]:
International Organization for Standardization, 1992. <i>Extended
Facilities Annexe.</i> [Geneva]: International Organization for
Standardization, 1996.</dd>
</dl>

<h2><a id="CharClasses" name="CharClasses"></a>B Character
Classes</h2>

<p>Following the characteristics defined in the Unicode standard,
characters are classed as base characters (among others, these
contain the alphabetic characters of the Latin alphabet, without
diacritics), ideographic characters, and combining characters
(among others, this class contains most diacritics); these classes
combine to form the class of letters. Digits and extenders are also
distinguished.</p>

<h5>Characters</h5>

<table class="scrap">
<tbody>
<tr valign="baseline">
<td><a id="NT-Letter" name="NT-Letter"></a>[84]   </td>
<td>Letter</td>
<td>   ::=   </td>
<td><a href="#NT-BaseChar">BaseChar</a> | <a
href="#NT-Ideographic">Ideographic</a></td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-BaseChar" name="NT-BaseChar"></a>[85]   </td>
<td>BaseChar</td>
<td>   ::=   </td>
<td>[#x0041-#x005A] |[#x0061-#x007A] |[#x00C0-#x00D6]
|[#x00D8-#x00F6] |[#x00F8-#x00FF] |[#x0100-#x0131] |[#x0134-#x013E]
|[#x0141-#x0148] |[#x014A-#x017E] |[#x0180-#x01C3] |[#x01CD-#x01F0]
|[#x01F4-#x01F5] |[#x01FA-#x0217] |[#x0250-#x02A8] |[#x02BB-#x02C1]
|#x0386 |[#x0388-#x038A] |#x038C |[#x038E-#x03A1] |[#x03A3-#x03CE]
|[#x03D0-#x03D6] |#x03DA |#x03DC |#x03DE |#x03E0 |[#x03E2-#x03F3]
|[#x0401-#x040C] |[#x040E-#x044F] |[#x0451-#x045C] |[#x045E-#x0481]
|[#x0490-#x04C4] |[#x04C7-#x04C8] |[#x04CB-#x04CC] |[#x04D0-#x04EB]
|[#x04EE-#x04F5] |[#x04F8-#x04F9] |[#x0531-#x0556] |#x0559
|[#x0561-#x0586] |[#x05D0-#x05EA] |[#x05F0-#x05F2] |[#x0621-#x063A]
|[#x0641-#x064A] |[#x0671-#x06B7] |[#x06BA-#x06BE] |[#x06C0-#x06CE]
|[#x06D0-#x06D3] |#x06D5 |[#x06E5-#x06E6] |[#x0905-#x0939] |#x093D
|[#x0958-#x0961] |[#x0985-#x098C] |[#x098F-#x0990] |[#x0993-#x09A8]
|[#x09AA-#x09B0] |#x09B2 |[#x09B6-#x09B9] |[#x09DC-#x09DD]
|[#x09DF-#x09E1] |[#x09F0-#x09F1] |[#x0A05-#x0A0A] |[#x0A0F-#x0A10]
|[#x0A13-#x0A28] |[#x0A2A-#x0A30] |[#x0A32-#x0A33] |[#x0A35-#x0A36]
|[#x0A38-#x0A39] |[#x0A59-#x0A5C] |#x0A5E |[#x0A72-#x0A74]
|[#x0A85-#x0A8B] |#x0A8D |[#x0A8F-#x0A91] |[#x0A93-#x0AA8]
|[#x0AAA-#x0AB0] |[#x0AB2-#x0AB3] |[#x0AB5-#x0AB9] |#x0ABD |#x0AE0
|[#x0B05-#x0B0C] |[#x0B0F-#x0B10] |[#x0B13-#x0B28] |[#x0B2A-#x0B30]
|[#x0B32-#x0B33] |[#x0B36-#x0B39] |#x0B3D |[#x0B5C-#x0B5D]
|[#x0B5F-#x0B61] |[#x0B85-#x0B8A] |[#x0B8E-#x0B90] |[#x0B92-#x0B95]
|[#x0B99-#x0B9A] |#x0B9C |[#x0B9E-#x0B9F] |[#x0BA3-#x0BA4]
|[#x0BA8-#x0BAA] |[#x0BAE-#x0BB5] |[#x0BB7-#x0BB9] |[#x0C05-#x0C0C]
|[#x0C0E-#x0C10] |[#x0C12-#x0C28] |[#x0C2A-#x0C33] |[#x0C35-#x0C39]
|[#x0C60-#x0C61] |[#x0C85-#x0C8C] |[#x0C8E-#x0C90] |[#x0C92-#x0CA8]
|[#x0CAA-#x0CB3] |[#x0CB5-#x0CB9] |#x0CDE |[#x0CE0-#x0CE1]
|[#x0D05-#x0D0C] |[#x0D0E-#x0D10] |[#x0D12-#x0D28] |[#x0D2A-#x0D39]
|[#x0D60-#x0D61] |[#x0E01-#x0E2E] |#x0E30 |[#x0E32-#x0E33]
|[#x0E40-#x0E45] |[#x0E81-#x0E82] |#x0E84 |[#x0E87-#x0E88] |#x0E8A
|#x0E8D |[#x0E94-#x0E97] |[#x0E99-#x0E9F] |[#x0EA1-#x0EA3] |#x0EA5
|#x0EA7 |[#x0EAA-#x0EAB] |[#x0EAD-#x0EAE] |#x0EB0 |[#x0EB2-#x0EB3]
|#x0EBD |[#x0EC0-#x0EC4] |[#x0F40-#x0F47] |[#x0F49-#x0F69]
|[#x10A0-#x10C5] |[#x10D0-#x10F6] |#x1100 |[#x1102-#x1103]
|[#x1105-#x1107] |#x1109 |[#x110B-#x110C] |[#x110E-#x1112] |#x113C
|#x113E |#x1140 |#x114C |#x114E |#x1150 |[#x1154-#x1155] |#x1159
|[#x115F-#x1161] |#x1163 |#x1165 |#x1167 |#x1169 |[#x116D-#x116E]
|[#x1172-#x1173] |#x1175 |#x119E |#x11A8 |#x11AB |[#x11AE-#x11AF]
|[#x11B7-#x11B8] |#x11BA |[#x11BC-#x11C2] |#x11EB |#x11F0 |#x11F9
|[#x1E00-#x1E9B] |[#x1EA0-#x1EF9] |[#x1F00-#x1F15] |[#x1F18-#x1F1D]
|[#x1F20-#x1F45] |[#x1F48-#x1F4D] |[#x1F50-#x1F57] |#x1F59 |#x1F5B
|#x1F5D |[#x1F5F-#x1F7D] |[#x1F80-#x1FB4] |[#x1FB6-#x1FBC] |#x1FBE
|[#x1FC2-#x1FC4] |[#x1FC6-#x1FCC] |[#x1FD0-#x1FD3] |[#x1FD6-#x1FDB]
|[#x1FE0-#x1FEC] |[#x1FF2-#x1FF4] |[#x1FF6-#x1FFC] |#x2126
|[#x212A-#x212B] |#x212E |[#x2180-#x2182] |[#x3041-#x3094]
|[#x30A1-#x30FA] |[#x3105-#x312C] |[#xAC00-#xD7A3]</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-Ideographic" name="NT-Ideographic"></a>[86]   </td>
<td>Ideographic</td>
<td>   ::=   </td>
<td>[#x4E00-#x9FA5] |#x3007 |[#x3021-#x3029]</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-CombiningChar"
name="NT-CombiningChar"></a>[87]   </td>
<td>CombiningChar</td>
<td>   ::=   </td>
<td>[#x0300-#x0345] |[#x0360-#x0361] |[#x0483-#x0486]
|[#x0591-#x05A1] |[#x05A3-#x05B9] |[#x05BB-#x05BD] |#x05BF
|[#x05C1-#x05C2] |#x05C4 |[#x064B-#x0652] |#x0670 |[#x06D6-#x06DC]
|[#x06DD-#x06DF] |[#x06E0-#x06E4] |[#x06E7-#x06E8] |[#x06EA-#x06ED]
|[#x0901-#x0903] |#x093C |[#x093E-#x094C] |#x094D |[#x0951-#x0954]
|[#x0962-#x0963] |[#x0981-#x0983] |#x09BC |#x09BE |#x09BF
|[#x09C0-#x09C4] |[#x09C7-#x09C8] |[#x09CB-#x09CD] |#x09D7
|[#x09E2-#x09E3] |#x0A02 |#x0A3C |#x0A3E |#x0A3F |[#x0A40-#x0A42]
|[#x0A47-#x0A48] |[#x0A4B-#x0A4D] |[#x0A70-#x0A71] |[#x0A81-#x0A83]
|#x0ABC |[#x0ABE-#x0AC5] |[#x0AC7-#x0AC9] |[#x0ACB-#x0ACD]
|[#x0B01-#x0B03] |#x0B3C |[#x0B3E-#x0B43] |[#x0B47-#x0B48]
|[#x0B4B-#x0B4D] |[#x0B56-#x0B57] |[#x0B82-#x0B83] |[#x0BBE-#x0BC2]
|[#x0BC6-#x0BC8] |[#x0BCA-#x0BCD] |#x0BD7 |[#x0C01-#x0C03]
|[#x0C3E-#x0C44] |[#x0C46-#x0C48] |[#x0C4A-#x0C4D] |[#x0C55-#x0C56]
|[#x0C82-#x0C83] |[#x0CBE-#x0CC4] |[#x0CC6-#x0CC8] |[#x0CCA-#x0CCD]
|[#x0CD5-#x0CD6] |[#x0D02-#x0D03] |[#x0D3E-#x0D43] |[#x0D46-#x0D48]
|[#x0D4A-#x0D4D] |#x0D57 |#x0E31 |[#x0E34-#x0E3A] |[#x0E47-#x0E4E]
|#x0EB1 |[#x0EB4-#x0EB9] |[#x0EBB-#x0EBC] |[#x0EC8-#x0ECD]
|[#x0F18-#x0F19] |#x0F35 |#x0F37 |#x0F39 |#x0F3E |#x0F3F
|[#x0F71-#x0F84] |[#x0F86-#x0F8B] |[#x0F90-#x0F95] |#x0F97
|[#x0F99-#x0FAD] |[#x0FB1-#x0FB7] |#x0FB9 |[#x20D0-#x20DC] |#x20E1
|[#x302A-#x302F] |#x3099 |#x309A</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-Digit" name="NT-Digit"></a>[88]   </td>
<td>Digit</td>
<td>   ::=   </td>
<td>[#x0030-#x0039] |[#x0660-#x0669] |[#x06F0-#x06F9]
|[#x0966-#x096F] |[#x09E6-#x09EF] |[#x0A66-#x0A6F] |[#x0AE6-#x0AEF]
|[#x0B66-#x0B6F] |[#x0BE7-#x0BEF] |[#x0C66-#x0C6F] |[#x0CE6-#x0CEF]
|[#x0D66-#x0D6F] |[#x0E50-#x0E59] |[#x0ED0-#x0ED9]
|[#x0F20-#x0F29]</td>
<td></td>
</tr>

<tr valign="baseline">
<td><a id="NT-Extender" name="NT-Extender"></a>[89]   </td>
<td>Extender</td>
<td>   ::=   </td>
<td>#x00B7 |#x02D0 |#x02D1 |#x0387 |#x0640 |#x0E46 |#x0EC6 |#x3005
|[#x3031-#x3035] |[#x309D-#x309E] |[#x30FC-#x30FE]</td>
<td></td>
</tr>
</tbody>
</table>

<br />
<br />
 

<p>The character classes defined here can be derived from the
Unicode character database as follows:</p>

<ul>
<li>
<p>Name start characters must have one of the categories Ll, Lu,
Lo, Lt, Nl.</p>
</li>

<li>
<p>Name characters other than Name-start characters must have one
of the categories Mc, Me, Mn, Lm, or Nd.</p>
</li>

<li>
<p>Characters in the compatibility area (i.e. with character code
greater than #xF900 and less than #xFFFE) are not allowed in XML
names.</p>
</li>

<li>
<p>Characters which have a font or compatibility decomposition
(i.e. those with a "compatibility formatting tag" in field 5 of the
database -- marked by field 5 beginning with a "&lt;") are not
allowed.</p>
</li>

<li>
<p>The following characters are treated as name-start characters
rather than name characters, because the property file classifies
them as Alphabetic: [#x02BB-#x02C1], #x0559, #x06E5, #x06E6.</p>
</li>

<li>
<p>Characters #x20DD-#x20E0 are excluded (in accordance with
Unicode, section 5.14).</p>
</li>

<li>
<p>Character #x00B7 is classified as an extender, because the
property list so identifies it.</p>
</li>

<li>
<p>Character #x0387 is added as a name character, because #x00B7 is
its canonical equivalent.</p>
</li>

<li>
<p>Characters ':' and '_' are allowed as name-start characters.</p>
</li>

<li>
<p>Characters '-' and '.' are allowed as name characters.</p>
</li>
</ul>

<br />
<br />
 

<h2><a id="sec-xml-and-sgml" name="sec-xml-and-sgml"></a>C XML and
SGML (Non-Normative)</h2>

<p>XML is designed to be a subset of SGML, in that every <a
href="#dt-valid">valid</a> XML document should also be a conformant
SGML document. For a detailed comparison of the additional
restrictions that XML places on documents beyond those of SGML, see
<a href="#Clark">[]</a>.</p>

<h2><a id="sec-entexpand" name="sec-entexpand"></a>D Expansion of
Entity and Character References (Non-Normative)</h2>

<p>This appendix contains some examples illustrating the sequence
of entity- and character-reference recognition and expansion, as
specified in <a href="#entproc">[]</a>.</p>

<p>If the DTD contains the declaration</p>

<pre>
&lt;!ENTITY example "&lt;p&gt;An ampersand (&amp;#38;#38;) may be escaped
numerically (&amp;#38;#38;#38;) or with a general entity
(&amp;amp;amp;).&lt;/p&gt;" &gt;
</pre>

then the XML processor will recognize the character references when
it parses the entity declaration, and resolve them before storing
the following string as the value of the entity
"<code>example</code>": 

<pre>
&lt;p&gt;An ampersand (&amp;#38;) may be escaped
numerically (&amp;#38;#38;) or with a general entity
(&amp;amp;amp;).&lt;/p&gt;
</pre>

A reference in the document to "<code>&amp;example;</code>" will
cause the text to be reparsed, at which time the start- and
end-tags of the "<code>p</code>" element will be recognized and the
three references will be recognized and expanded, resulting in a
"<code>p</code>" element with the following content (all data, no
delimiters or markup): 

<pre>
An ampersand (&amp;) may be escaped
numerically (&amp;#38;) or with a general entity
(&amp;amp;).
</pre>

<br />
<br />
 

<p>A more complex example will illustrate the rules and their
effects fully. In the following example, the line numbers are
solely for reference.</p>

<pre>
1 &lt;?xml version='1.0'?&gt;
2 &lt;!DOCTYPE test [
3 &lt;!ELEMENT test (#PCDATA) &gt;
4 &lt;!ENTITY % xx '&amp;#37;zz;'&gt;
5 &lt;!ENTITY % zz '&amp;#60;!ENTITY tricky "error-prone" &gt;' &gt;
6 %xx;
7 ]&gt;
8 &lt;test&gt;This sample shows a &amp;tricky; method.&lt;/test&gt;
</pre>

This produces the following: 

<ul>
<li>
<p>in line 4, the reference to character 37 is expanded
immediately, and the parameter entity "<code>xx</code>" is stored
in the symbol table with the value "<code>%zz;</code>". Since the
replacement text is not rescanned, the reference to parameter
entity "<code>zz</code>" is not recognized. (And it would be an
error if it were, since "<code>zz</code>" is not yet declared.)</p>
</li>

<li>
<p>in line 5, the character reference "<code>&amp;#60;</code>" is
expanded immediately and the parameter entity "<code>zz</code>" is
stored with the replacement text "<code>&lt;!ENTITY tricky
"error-prone" &gt;</code>", which is a well-formed entity
declaration.</p>
</li>

<li>
<p>in line 6, the reference to "<code>xx</code>" is recognized, and
the replacement text of "<code>xx</code>" (namely
"<code>%zz;</code>") is parsed. The reference to "<code>zz</code>"
is recognized in its turn, and its replacement text
("<code>&lt;!ENTITY tricky "error-prone" &gt;</code>") is parsed.
The general entity "<code>tricky</code>" has now been declared,
with the replacement text "<code>error-prone</code>".</p>
</li>

<li>
<p>in line 8, the reference to the general entity
"<code>tricky</code>" is recognized, and it is expanded, so the
full content of the "<code>test</code>" element is the
self-describing (and ungrammatical) string <i>This sample shows a
error-prone method.</i></p>
</li>
</ul>

<br />
<br />
 

<h2><a id="determinism" name="determinism"></a>E Deterministic
Content Models (Non-Normative)</h2>

<p><a href="#dt-compat">For compatibility</a>, it is required that
content models in element type declarations be deterministic.</p>

<p>SGML requires deterministic content models (it calls them
"unambiguous"); XML processors built using SGML systems may flag
non-deterministic content models as errors.</p>

<p>For example, the content model <code>((b, c) | (b, d))</code> is
non-deterministic, because given an initial <code>b</code> the
parser cannot know which <code>b</code> in the model is being
matched without looking ahead to see which element follows the
<code>b</code>. In this case, the two references to <code>b</code>
can be collapsed into a single reference, making the model read
<code>(b, (c | d))</code>. An initial <code>b</code> now clearly
matches only a single name in the content model. The parser doesn't
need to look ahead to see what follows; either <code>c</code> or
<code>d</code> would be accepted.</p>

<p>More formally: a finite state automaton may be constructed from
the content model using the standard algorithms, e.g. algorithm 3.5
in section 3.9 of Aho, Sethi, and Ullman <a href="#Aho">[]</a>. In
many such algorithms, a follow set is constructed for each position
in the regular expression (i.e., each leaf node in the syntax tree
for the regular expression); if any position has a follow set in
which more than one following position is labeled with the same
element type name, then the content model is in error and may be
reported as an error.</p>

<p>Algorithms exist which allow many but not all non-deterministic
content models to be reduced automatically to equivalent
deterministic models; see Brüggemann-Klein 1991 <a
href="#ABK">[]</a>.</p>

<h2><a id="sec-guessing" name="sec-guessing"></a>F Autodetection of
Character Encodings (Non-Normative)</h2>

<p>The XML encoding declaration functions as an internal label on
each entity, indicating which character encoding is in use. Before
an XML processor can read the internal label, however, it
apparently has to know what character encoding is in usewhich is
what the internal label is trying to indicate. In the general case,
this is a hopeless situation. It is not entirely hopeless in XML,
however, because XML limits the general case in two ways: each
implementation is assumed to support only a finite set of character
encodings, and the XML encoding declaration is restricted in
position and content in order to make it feasible to autodetect the
character encoding in use in each entity in normal cases. Also, in
many cases other sources of information are available in addition
to the XML data stream itself. Two cases may be distinguished,
depending on whether the XML entity is presented to the processor
without, or with, any accompanying (external) information. We
consider the first case first.</p>

<p>Because each XML entity not in UTF-8 or UTF-16 format
<i>must</i> begin with an XML encoding declaration, in which the
first characters must be '<code>&lt;?xml</code>', any conforming
processor can detect, after two to four octets of input, which of
the following cases apply. In reading this list, it may help to
know that in UCS-4, '&lt;' is "<code>#x0000003C</code>" and '?' is
"<code>#x0000003F</code>", and the Byte Order Mark required of
UTF-16 data streams is "<code>#xFEFF</code>".</p>

<ul>
<li>
<p><code>00 00 00 3C</code>: UCS-4, big-endian machine (1234
order)</p>
</li>

<li>
<p><code>3C 00 00 00</code>: UCS-4, little-endian machine (4321
order)</p>
</li>

<li>
<p><code>00 00 3C 00</code>: UCS-4, unusual octet order (2143)</p>
</li>

<li>
<p><code>00 3C 00 00</code>: UCS-4, unusual octet order (3412)</p>
</li>

<li>
<p><code>FE FF</code>: UTF-16, big-endian</p>
</li>

<li>
<p><code>FF FE</code>: UTF-16, little-endian</p>
</li>

<li>
<p><code>00 3C 00 3F</code>: UTF-16, big-endian, no Byte Order Mark
(and thus, strictly speaking, in error)</p>
</li>

<li>
<p><code>3C 00 3F 00</code>: UTF-16, little-endian, no Byte Order
Mark (and thus, strictly speaking, in error)</p>
</li>

<li>
<p><code>3C 3F 78 6D</code>: UTF-8, ISO 646, ASCII, some part of
ISO 8859, Shift-JIS, EUC, or any other 7-bit, 8-bit, or mixed-width
encoding which ensures that the characters of ASCII have their
normal positions, width, and values; the actual encoding
declaration must be read to detect which of these applies, but
since all of these encodings use the same bit patterns for the
ASCII characters, the encoding declaration itself may be read
reliably</p>
</li>

<li>
<p><code>4C 6F A7 94</code>: EBCDIC (in some flavor; the full
encoding declaration must be read to tell which code page is in
use)</p>
</li>

<li>
<p>other: UTF-8 without an encoding declaration, or else the data
stream is corrupt, fragmentary, or enclosed in a wrapper of some
kind</p>
</li>
</ul>

<br />
<br />
 

<p>This level of autodetection is enough to read the XML encoding
declaration and parse the character-encoding identifier, which is
still necessary to distinguish the individual members of each
family of encodings (e.g. to tell UTF-8 from 8859, and the parts of
8859 from each other, or to distinguish the specific EBCDIC code
page in use, and so on).</p>

<p>Because the contents of the encoding declaration are restricted
to ASCII characters, a processor can reliably read the entire
encoding declaration as soon as it has detected which family of
encodings is in use. Since in practice, all widely used character
encodings fall into one of the categories above, the XML encoding
declaration allows reasonably reliable in-band labeling of
character encodings, even when external sources of information at
the operating-system or transport-protocol level are
unreliable.</p>

<p>Once the processor has detected the character encoding in use,
it can act appropriately, whether by invoking a separate input
routine for each case, or by calling the proper conversion function
on each character of input.</p>

<p>Like any self-labeling system, the XML encoding declaration will
not work if any software changes the entity's character set or
encoding without updating the encoding declaration. Implementors of
character-encoding routines should be careful to ensure the
accuracy of the internal and external information used to label the
entity.</p>

<p>The second possible case occurs when the XML entity is
accompanied by encoding information, as in some file systems and
some network protocols. When multiple sources of information are
available, their relative priority and the preferred method of
handling conflict should be specified as part of the higher-level
protocol used to deliver XML. Rules for the relative priority of
the internal label and the MIME-type label in an external header,
for example, should be part of the RFC document defining the
text/xml and application/xml MIME types. In the interests of
interoperability, however, the following rules are recommended.</p>

<ul>
<li>
<p>If an XML entity is in a file, the Byte-Order Mark and
encoding-declaration PI are used (if present) to determine the
character encoding. All other heuristics and sources of information
are solely for error recovery.</p>
</li>

<li>
<p>If an XML entity is delivered with a MIME type of text/xml, then
the <code>charset</code> parameter on the MIME type determines the
character encoding method; all other heuristics and sources of
information are solely for error recovery.</p>
</li>

<li>
<p>If an XML entity is delivered with a MIME type of
application/xml, then the Byte-Order Mark and encoding-declaration
PI are used (if present) to determine the character encoding. All
other heuristics and sources of information are solely for error
recovery.</p>
</li>
</ul>

These rules apply only in the absence of protocol-level
documentation; in particular, when the MIME types text/xml and
application/xml are defined, the recommendations of the relevant
RFC will supersede these rules. <br />
<br />
 

<h2><a id="sec-xml-wg" name="sec-xml-wg"></a>G W3C XML Working
Group (Non-Normative)</h2>

<p>This specification was prepared and approved for publication by
the W3C XML Working Group (WG). WG approval of this specification
does not necessarily imply that all WG members voted for its
approval. The current and former members of the XML WG are:</p>

Jon Bosak, Sun (Chair); James Clark (Technical Lead); Tim Bray,
Textuality and Netscape (XML Co-editor); Jean Paoli, Microsoft (XML
Co-editor); C. M. Sperberg-McQueen, U. of Ill. (XML Co-editor); Dan
Connolly, W3C (W3C Liaison); Paula Angerstein, Texcel; Steve
DeRose, INSO; Dave Hollander, HP; Eliot Kimber, ISOGEN; Eve Maler,
ArborText; Tom Magliery, NCSA; Murray Maloney, Muzmo and Grif;
Makoto Murata, Fuji Xerox Information Systems; Joel Nava, Adobe;
Conleth O'Connell, Vignette; Peter Sharpe, SoftQuad; John Tigue,
DataChannel
</body>
</html>

